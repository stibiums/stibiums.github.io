---
layout: post
title: notes of Rustlearning
date: 2025-07-08 08:00:00
description: 这是我学习Rust语言的笔记.
tags: notes
categories: my-notes
toc:
  sidebar: left
---

学习使用的[教程](https://kaisery.github.io/trpl-zh-cn/title-page.html)

## hello world 和 hello cargo

### hello world

创建一个以`hello.rs`文件，内容如下：

```rust
fn main() {
    println!("Hello, world!");
}
```

然后在终端中运行：

```bash
rustc hello.rs
./hello
```

便会运行输出`Hello, world!`。这是最简单编写运行Rust程序的方式。

### cargo

Cargo 是 Rust 的构建系统和包管理器。使用 Cargo 来管理 Rust 项目，它可以为你处理很多任务，比如构建代码、下载依赖库并编译这些库。

使用cargo创建项目的方法：

```bash
cargo new hello_cargo
cd hello_cargo
```

进入 hello_cargo 目录并列出文件。将会看到 Cargo 生成了两个文件和一个目录：一个 Cargo.toml 文件，一个 src 目录，以及位于 src 目录中的 main.rs 文件。

如果要在已有的文件里使用 Cargo，可以在项目目录下运行：

```bash
cargo init
```

### 编译和运行

在项目目录下运行：

```bash
cargo build
```

这会编译项目并生成可执行文件。可执行文件位于 `target/debug/` 目录下。如果需要发布时可以加上参数`--release`，这样会进行优化编译：

要运行项目，可以使用：

```bash
cargo run
```

Cargo 还提供了一个叫 `cargo check` 的命令。该命令快速检查代码确保其可以编译，但并不产生可执行文件

## 常见编程概念的迁移

### 变量和可变性

#### 变量的定义

在 Rust 中，使用`let`声明一个变量。变量默认是不可变的。要声明一个可变变量，可以使用 `mut` 关键字：

```rust
let x = 5; // 不可变变量
let mut y = 10; // 可变变量
```

如果尝试修改不可变变量，会导致编译错误。Rust的编译器会保证不可变的变量不会发生改变。

#### 常量

常量使用 `const` 关键字声明，在声明时也必须指明其数据类型，必须在编译时就确定值。常量可以在任何作用域中使用，包括函数内部和外部。

```rust
const THREE_HOURS_IN_SECONDS: u32 = 60 * 60 * 3;
```

常量可以用常量表达式来定义

在声明它的作用域之中，常量在整个程序生命周期中都有效

#### 遮蔽

遮蔽是指使用同名变量来隐藏之前的变量。可以通过重新声明一个变量来遮蔽之前的变量。

第二个变量遮蔽了第一个变量，此时任何使用该变量名的行为中都会视为是在使用第二个变量，直到第二个变量自己也被遮蔽或第二个变量的作用域结束。

```rust
fn main() {
    let x = 5;

    let x = x + 1;

    {
        let x = x * 2;
        println!("The value of x in the inner scope is: {x}");
    }

    println!("The value of x is: {x}");
}
```

遮蔽和变量修改是有不同的；遮蔽创建的新的变量，修改原来的变量则是改变原来的变量的值。

### 数据类型

Rust 是一种静态类型的语言，在编译时就必须确定所有变量的类型。在定义变量或者常量时，可以使用类型注解来指定变量的类型。

有两种数据类型：标量类型和复合类型。

#### 标量类型

标量类型表示单一的值。Rust 中有四种基本的标量类型：整数、浮点数、布尔值和字符。

##### 整型

以下是 Rust 中整型的整理表格：

| **类型** | **长度** | **范围**                                                                            | **示例**                                                  |
| -------- | -------- | ----------------------------------------------------------------------------------- | --------------------------------------------------------- |
| `i8`     | 8 位     | -128 到 127                                                                         | `let x: i8 = -100;`                                       |
| `u8`     | 8 位     | 0 到 255                                                                            | `let x: u8 = 200;`                                        |
| `i16`    | 16 位    | -32,768 到 32,767                                                                   | `let x: i16 = -30000;`                                    |
| `u16`    | 16 位    | 0 到 65,535                                                                         | `let x: u16 = 60000;`                                     |
| `i32`    | 32 位    | -2,147,483,648 到 2,147,483,647                                                     | `let x: i32 = -2000000;`                                  |
| `u32`    | 32 位    | 0 到 4,294,967,295                                                                  | `let x: u32 = 4000000;`                                   |
| `i64`    | 64 位    | -9,223,372,036,854,775,808 到 9,223,372,036,854,775,807                             | `let x: i64 = -9000000000000000000;`                      |
| `u64`    | 64 位    | 0 到 18,446,744,073,709,551,615                                                     | `let x: u64 = 18000000000000000000;`                      |
| `i128`   | 128 位   | -170141183460469231731687303715884105728 到 170141183460469231731687303715884105727 | `let x: i128 = -170000000000000000000000000000000000000;` |
| `u128`   | 128 位   | 0 到 340282366920938463463374607431768211455                                        | `let x: u128 = 340000000000000000000000000000000000000;`  |
| `isize`  | 平台相关 | 取决于操作系统（32 位或 64 位）                                                     | `let x: isize = -1000;`                                   |
| `usize`  | 平台相关 | 取决于操作系统（32 位或 64 位）                                                     | `let x: usize = 1000;`                                    |

---

**说明**：

1. **`i` 表示有符号整型**，可以表示正数和负数。
2. **`u` 表示无符号整型**，只能表示非负数。
3. **`isize` 和 `usize`** 是平台相关的整型类型：
   - 在 32 位系统上，它们分别是 32 位。
   - 在 64 位系统上，它们分别是 64 位。
4. **默认类型**：如果没有显式指定类型，Rust 会默认使用 `i32` 类型。

##### 浮点型

Rust 的浮点数类型是 f32 和 f64，分别占 32 位和 64 位。默认类型是 f64

##### 布尔型

布尔类型只有两个值：true 和 false。可以使用 `bool` 类型来声明

##### 字符型

字符类型使用 `char` 类型来表示，表示单个 Unicode 字符。字符类型是四个字节（32 位），可以表示任何有效的 Unicode 字符，带变音符号的字母（Accented letters），中文、日文、韩文等字符，emoji（绘文字）以及零长度的空白字符都是有效的 char 值

```rust
fn main() {
    let c = 'z';
    let z: char = 'ℤ'; // with explicit type annotation
    let heart_eyed_cat = '😻';
}
```

#### 复合类型

复合类型可以将多个值组合成一个值。Rust 中有两种基本的复合类型：元组和数组。

##### 元组

元组是将多个值组合成一个复合类型。元组的元素可以是不同类型的。元组使用小括号 `()` 来表示，元素之间用逗号分隔。

```rust
fn main() {
    let tup: (i32, f64, u8) = (500, 6.4, 1);

    let (x, y, z) = tup; // 支持解构

    println!("The value of y is: {y}");
}
```

可以使用`.` 加上索引来访问元组的元素

##### 数组

数组是固定长度的同类型元素的集合。数组使用方括号 `[]` 来表示，元素之间用逗号分隔。

```rust
fn main() {
    let a: [i32; 5] = [1, 2, 3, 4, 5]; //方括号中包含每个元素的类型，后跟分号，再后跟数组元素的数量
    let a = [3; 5]; // 创建一个包含 5 个元素的数组，每个元素的值都是 3
    let first = a[0]; // 访问数组的第一个元素
}
```

### 函数
