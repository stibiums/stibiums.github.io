---
layout: post
title: "VCI - 6: 图像表示与处理"
date: 2025-10-11 04:00:00
tags: notes vci
categories: vci
---

## 6.1 图像的定义

**图像（Image）** 是二维平面上光能量的分布，可以表示为：

$$
E(x, y, \lambda, t)
$$

其中：

- $$x, y$$ - 空间位置坐标
- $$\lambda$$ - 波长（蓝色、绿色、黄色、红色、紫色等）
- $$t$$ - 时间

这是一个**连续表示**，在计算机中难以直接表示，需要进行离散化处理。

**成像过程：** 光源照射场景中的物体，反射的光线经过成像系统（如相机镜头）后，在图像平面上形成光能量的二维分布。这个分布就是我们所说的图像。

---

## 6.2 图像的表示方法

### 6.2.1 矢量表示 (Vector Representation)

**优点：**

- 任意分辨率，可无限缩放
- 适合线条图（文本、图标等）
- 文件小（只存储数学描述）

**缺点：**

- 可能重复绘制同一点
- 难以表示复杂的颜色变化
- 不适合照片类图像

**应用：** SVG格式、矢量图形编辑器

### 6.2.2 栅格表示 (Raster Representation)

**优点：**

- 适合彩色图像
- 通用性强，能表示任何图像
- 显示速度快

**缺点：**

- 分辨率有限（存在锯齿/走样）
- 需要存储每个像素
- 缩放会导致质量损失

**应用：** JPEG、PNG、BMP等图像格式

**核心差异：**

- **矢量图** 使用数学描述（线条、曲线、几何形状），放大后仍保持清晰
- **栅格图** 使用像素网格存储，放大后会出现锯齿和像素化现象
- 矢量适合图标和文字，栅格适合照片和复杂图像

---

## 6.3 帧缓冲区 (Framebuffer)

### 6.3.1 基本概念

**帧缓冲区** 是存储二维像素数组的内存区域。

- **图像：** 二维像素数组
- **像素值：** 控制每个像素的亮度
- **刷新频率：** 视频硬件以约60Hz的频率扫描帧缓冲区
- **实时更新：** 对帧缓冲区的修改会立即显示

### 6.3.2 像素深度

**不同显示器支持的像素深度：**

- **黑白显示：** 1 bit/pixel（位图）
- **基础彩色显示：** 8、16或24 bits/pixel
- **高端显示：** 96位或更多

**工作机制：** 帧缓冲区存储像素值，视频硬件以约60Hz的频率周期性扫描这些值并驱动显示器。现代显示器（LCD、OLED）本质上就是一个二维像素阵列，每个像素对应帧缓冲区中的一个存储位置。

---

## 6.4 颜色图像存储

### 6.4.1 全彩色 (RGB) 存储

**24位色彩：**

- R、G、B各8位（每个通道0-255）
- 例：$$(255, 0, 0)$$ 表示纯红色，$$(255, 255, 255)$$ 表示白色
- 可产生 $$2^{24} = 16,777,216$$ 种颜色

**15位色彩：**

- R、G、B各5位
- 较低的颜色精度，但存储空间减半

**存储方式：** 每个像素存储R、G、B三个独立分量，视频硬件使用这些值驱动显示器的红、绿、蓝电子枪（CRT）或子像素（LCD/OLED）。

### 6.4.2 颜色查找表 (Colormap/LUT)

**索引颜色模式：**

- 每个像素存储一个索引值（如8位）
- 索引指向颜色查找表中的RGB三元组
- 8位索引可表示256种预设颜色

**适用场景：**

- 灰度图像（灰度渐变表）
- 预定义颜色集
- 自适应颜色调色板

**工作原理：** 像素存储索引值（如112），通过查找表映射到实际的RGB值（如255, 0, 0表示红色）。这种方式可以节省存储空间（像素只需8位），但颜色数量受限（最多256种）。例如：`pixel[x,y] = 112 → LUT[112] = (255, 0, 0)`。

---

## 6.5 常见图像文件格式

| 格式    | 位深度  | 文件大小 | 特点                       |
| ------- | ------- | -------- | -------------------------- |
| JPEG    | 24      | 小       | 有损压缩                   |
| TIFF    | 8, 24   | 中等     | 通用格式                   |
| GIF     | 1, 4, 8 | 中等     | 支持动画，8位限制          |
| PPM     | 24      | 大       | 易于读写                   |
| EPS     | 1-24    | 巨大     | 适合打印                   |
| **PNG** | 1-32    | 中等     | **无损压缩，支持透明通道** |
| **BMP** | 1-32    | 大       | Windows位图格式            |

**PNG格式** 是现代Web和数字图像的首选格式，支持透明通道（Alpha通道），无损压缩。

---

## 6.6 Alpha通道与图像合成

### 6.6.1 Alpha通道

**Alpha通道** 是像素的额外8位，用于表示透明度：

- $$\alpha = 0$$：完全透明
- $$\alpha = 1$$：完全不透明
- $$0 < \alpha < 1$$：半透明

通常作为8位数值存储（0-255），但在数学公式中规范化为$$[0, 1]$$。

### 6.6.2 图像合成公式

将图像$$a_2$$叠加到$$a_1$$上，使用遮罩$$\alpha$$：

$$
b = (1-\alpha) \cdot a_1 + \alpha \cdot a_2
$$

- $$\alpha = 0$$ 或 $$1$$：**硬遮罩** (Hard Matte)
- $$0 < \alpha < 1$$：**软遮罩** (Soft Matte)

**合成效果：** 通过Alpha通道，可以将前景图像$$a_2$$平滑地叠加到背景图像$$a_1$$上。Alpha通道中白色（$$\alpha=1$$）表示完全不透明，黑色（$$\alpha=0$$）表示完全透明，灰色（$$0<\alpha<1$$）表示半透明。这使得物体边缘可以实现平滑过渡，避免生硬的锯齿边缘。

**应用场景：**

- 照片修饰和特效
- 半透明多边形渲染
- 体积渲染

---

## 6.7 深度帧缓冲区

高端帧缓冲区可能有96位或更多，除了RGB和Alpha，还包括：

### 6.7.1 Z-buffer（深度缓冲区）

- 每像素16位，存储深度值
- 用于3D隐藏面消除
- 总计：RGB(24) + Alpha(8) + Z(16) = **48位**

### 6.7.2 双缓冲 (Double Buffering)

- **目的：** 实现流畅的实时动画，避免闪烁
- **机制：**
  - 维护两个完整的帧缓冲区
  - 一个可见（前缓冲区），一个不可见（后缓冲区）
  - 在后缓冲区绘制，然后瞬间交换
- **总计：** $$2 \times 48 = 96$$ 位

**双缓冲可以避免：**

- 绘制过程中的闪烁
- 部分绘制的画面被看到
- 撕裂现象

---

## 6.8 图像处理概述

**图像处理** 是对数字图像进行各种变换和操作的过程。

### 6.8.1 主要类别

**1. 点处理 (Point Processing)**

- 每个像素的输出仅取决于该像素的输入值
- $$b[x, y] = f(a[x, y])$$
- **应用：** 对比度调整、亮度变换、伽马校正

**2. 滤波 (Filtering)**

- 输出是输入像素邻域的函数
- **应用：** 模糊、锐化、边缘检测

**3. 其他操作**

- 图像变换（缩放、旋转、形变）
- 图像压缩（有损/无损）
- 图像分割
- 图像修复（Inpainting）
- 图像抠图（Matting）
- 视频处理

---

## 6.9 点处理

### 6.9.1 基本变换

假设像素值规范化到$$[0, 1]$$：

| 函数                        | 效果                       |
| --------------------------- | -------------------------- |
| $$f(v) = v$$                | 恒等（无变化）             |
| $$f(v) = 1 - v$$            | 图像反转（黑变白，白变黑） |
| $$f(v) = v^p, \quad p < 1$$ | 变亮                       |
| $$f(v) = v^p, \quad p > 1$$ | 变暗                       |

**伽马校正** 就是点处理的一种应用，用于补偿显示器的非线性响应。

---

## 6.10 图像滤波

### 6.10.1 线性滤波与卷积

**一维卷积：**

$$
b[x] = \sum_{t=-\infty}^{+\infty} a[t] \cdot h[x - t]
$$

简记为 $$b = a \otimes h$$

**二维卷积：**

$$
b[x, y] = \sum_{u=-\infty}^{+\infty} \sum_{v=-\infty}^{+\infty} a[u, v] \cdot h[x - u, y - v]
$$

其中：

- $$a[x, y]$$：输入信号/图像
- $$h[x, y]$$：滤波器/卷积核
- $$b[x, y]$$：输出信号/图像

**卷积的性质：**

- **交换律：** $$a \otimes h = h \otimes a$$
- **线性：** 满足叠加原理
- **平移不变性：** 滤波器在图像各处效果相同

### 6.10.2 模糊滤波器

**3×3均值模糊：**

$$
h = \frac{1}{9} \begin{pmatrix}
1 & 1 & 1 \\
1 & 1 & 1 \\
1 & 1 & 1
\end{pmatrix}
$$

**$$n \times n$$均值模糊：**

$$
h = \frac{1}{n^2} \begin{bmatrix}
1 & \cdots & 1 \\
\vdots & \ddots & \vdots \\
1 & \cdots & 1
\end{bmatrix}
$$

**效果说明：** 滤波器窗口越大，模糊程度越强。例如3×3模糊会产生轻微的平滑效果，而5×5或更大的滤波器会导致明显的模糊和细节损失。这种滤波器常用于降噪或创建景深效果。

### 6.10.3 边缘检测滤波器

**边缘检测的核心思想：** 计算图像的梯度（一阶导数）。

**图像梯度：**

$$
\nabla a = \left( \frac{\partial a}{\partial x}, \frac{\partial a}{\partial y} \right)
$$

**梯度幅值：**

$$
|\nabla a| = \sqrt{\left(\frac{\partial a}{\partial x}\right)^2 + \left(\frac{\partial a}{\partial y}\right)^2}
$$

**Sobel算子：**

$$
\frac{\partial}{\partial x} \Rightarrow \begin{pmatrix}
-1 & 0 & 1 \\
-2 & 0 & 2 \\
-1 & 0 & 1
\end{pmatrix}, \quad
\frac{\partial}{\partial y} \Rightarrow \begin{pmatrix}
1 & 2 & 1 \\
0 & 0 & 0 \\
-1 & -2 & -1
\end{pmatrix}
$$

**工作原理：**

- $$x$$方向Sobel算子检测垂直边缘（左右亮度变化）
- $$y$$方向Sobel算子检测水平边缘（上下亮度变化）
- 通过计算$$\|\nabla a\|$$得到边缘强度图，突出显示建筑物轮廓、窗户边缘等特征
- 注意：这是**非线性滤波器**，因为最终的梯度幅值计算包含平方根和平方运算

---

## 6.11 图像修复 (Image Inpainting)

### 6.11.1 问题定义

给定图像$$f^*$$，其中某些区域$$\Omega$$的信息丢失，目标是填充这些区域使结果尽可能**合理（Plausible）**。

**"合理"的含义：**

- **空间局部性：** 同一物体的邻近部分应该相似
- **奥卡姆剃刀原则：** 除非从图像其余部分推断出，否则不应存在多余信息
- **平滑性：** 平滑区域应具有尽可能小的梯度

### 6.11.2 Laplace编辑（拉普拉斯修复）

**优化目标：**

$$
f^* = \arg\min_{f} \iint_{\Omega} \|\nabla f\|^2 \quad \text{s.t.} \quad f|_{\partial\Omega} = f^*|_{\partial\Omega}
$$

即最小化区域内梯度的L2范数，同时保持边界值不变。

**欧拉-拉格朗日方程：**

$$
\Delta f = 0 \quad \text{s.t.} \quad f|_{\partial\Omega} = f^*|_{\partial\Omega}
$$

其中$$\Delta$$是拉普拉斯算子：

$$
\Delta = \frac{\partial^2}{\partial x^2} + \frac{\partial^2}{\partial y^2}
$$

这是一个**泊松方程**，可以通过数值方法求解。

<div class="row mt-3">
    <div class="col-sm-6 mt-3 mt-md-0">
        {% include figure.liquid loading="eager" path="assets/img/notes_img/vci-ch06/inpainting_input.png" title="图像修复输入" class="img-fluid rounded z-depth-1" zoomable=true %}
    </div>
    <div class="col-sm-6 mt-3 mt-md-0">
        {% include figure.liquid loading="eager" path="assets/img/notes_img/vci-ch06/inpainting_result.png" title="图像修复结果" class="img-fluid rounded z-depth-1" zoomable=true %}
    </div>
</div>

左图中的黑色区域（标记为$$\Omega$$，边界为$$\partial\Omega$$）是需要修复的缺失区域，右图展示了修复后的效果。算法基于周围像素的信息，通过求解泊松方程，平滑地填充了缺失区域，使得修复结果与周围环境自然融合。

---

## 6.12 泊松编辑 (Poisson Editing)

### 6.12.1 问题扩展

如何向修复区域"注入"某些形状或信息？

**修改优化目标：**

$$
f^* = \arg\min_{f} \iint_{\Omega} \|\nabla f - \mathbf{g}\|^2 \quad \text{s.t.} \quad f|_{\partial\Omega} = f^*|_{\partial\Omega}
$$

其中$$\mathbf{g}$$是**引导场** (Guidance Field)，通常是另一张图像的梯度。

**欧拉方程：**

$$
\Delta f = \operatorname{div}\mathbf{g} \quad \text{s.t.} \quad f\big|_{\partial\Omega} = f^*\big|_{\partial\Omega}
$$

其中，若

$$
\mathbf{g}=(g_x,g_y),
$$

则

$$
\operatorname{div}\mathbf{g}=\frac{\partial g_x}{\partial x}+\frac{\partial g_y}{\partial y}.
$$

$$
\operatorname{div}\mathbf{g}=\frac{\partial g_x}{\partial x}+\frac{\partial g_y}{\partial y}.
$$

该方程的物理含义是：在修复区域内注入引导场 \(\mathbf{g}\) 的梯度信息，使得解 \(f\) 在区域内部采用期望的局部变化（纹理或亮度），同时在边界 \(\partial\Omega\) 保持给定的边界条件，从而实现无缝融合或克隆。

**特例：**

- 当$$\mathbf{g} = 0$$时，泊松编辑退化为Laplace编辑（图像修复）
- 单色区域的填充就是这种特殊情况

### 6.12.2 泊松方程离散化

**连续形式：**

$$
\Delta f = -\rho, \quad \Delta \equiv \frac{\partial^2}{\partial x^2} + \frac{\partial^2}{\partial y^2}
$$

**离散形式（中心差分）：**

$$
\frac{f_{i+1,j} + f_{i-1,j} - 2f_{i,j}}{h^2} + \frac{f_{i,j+1} + f_{i,j-1} - 2f_{i,j}}{h^2} = \rho_{i,j}
$$

化简为：

$$
f_{i-1,j} + f_{i+1,j} + f_{i,j-1} + f_{i,j+1} - 4f_{i,j} = h^2 \rho_{i,j}
$$

这形成一个**稀疏线性方程组**，可以用迭代方法求解（如Jacobi、Gauss-Seidel、多重网格法）。

### 6.12.3 应用：图像克隆

泊松编辑的典型应用是**无缝图像克隆**：将一张图像中的物体无缝地克隆到另一张图像中，同时自动适应目标图像的光照和色调。

<div class="row mt-3">
    <div class="col-sm mt-3 mt-md-0">
        {% include figure.liquid loading="eager" path="assets/img/notes_img/vci-ch06/poisson_cloning.png" title="泊松克隆完整流程" class="img-fluid rounded z-depth-1" zoomable=true %}
    </div>
</div>

上图展示了图像克隆的完整流程：源图像中选择要克隆的区域，通过泊松方程求解，使用引导梯度场$$\mathbf{g}$$控制内部纹理，同时通过边界条件$$f\big|_{\partial\Omega}$$与目标场景自然融合。泊松编辑会根据边界条件自动调整颜色和亮度，实现物体与新背景的自然过渡。

---

## 6.13 图像抠图 (Image Matting)

### 6.13.1 问题定义

**图像抠图** 是图像合成的逆问题，目标是从图像中分离前景和背景。

**图像合成方程：**

$$
I_i = \alpha_i F_i + (1 - \alpha_i) B_i
$$

其中：

- $$I$$：观察到的图像
- $$F$$：前景
- $$B$$：背景
- $$\alpha$$：Alpha通道（透明度）

**RGB三通道形式：**

$$
\begin{cases}
I_i^R = \alpha_i F_i^R + (1 - \alpha_i) B_i^R \\
I_i^G = \alpha_i F_i^G + (1 - \alpha_i) B_i^G \\
I_i^B = \alpha_i F_i^B + (1 - \alpha_i) B_i^B
\end{cases}
$$

**病态问题：** 3个方程，7个未知数（$$\alpha, F_R, F_G, F_B, B_R, B_G, B_B$$）

### 6.13.2 蓝/绿幕抠图

**假设：**

- 背景已知且为纯蓝色（或绿色）
- 前景中不含蓝色（或绿色）

**简化：** $$F_b = 0, B_r = B_g = 0$$

**求解：**

$$
\begin{cases}
C_r = \alpha F_r \\
C_g = \alpha F_g \\
C_b = (1 - \alpha) B_b
\end{cases}
$$

可以直接从蓝色通道计算$$\alpha$$，从红绿通道计算前景。

**缺点：**

- 前景不能有蓝/绿色成分（限制性强）
- 蓝/绿溢色问题（Blue/Green Spilling）：背景反射光会污染前景

**应用：** 电影特效、虚拟演播室

---

## 6.14 小结

本章介绍了图像的表示和基础处理方法：

**图像表示：**

- 矢量表示 vs 栅格表示
- 帧缓冲区与像素存储
- RGB存储与颜色查找表
- Alpha通道与图像合成

**图像处理：**

- 点处理：对比度、亮度调整
- 滤波：模糊、锐化、边缘检测
- 图像修复：Laplace编辑
- 泊松编辑：图像克隆、无缝融合
- 图像抠图：前景背景分离

**数学工具：**

- 卷积与线性滤波
- 梯度与边缘检测
- 拉普拉斯算子与泊松方程
- 变分方法与优化

这些技术是现代图像编辑软件（Photoshop、GIMP）和计算机视觉算法的基础。
