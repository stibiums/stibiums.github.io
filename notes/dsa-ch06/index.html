<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> 数据结构与算法 - 第6章: 树（Tree） | STIBIUMS_WEB </title> <meta name="author" content="stibiums liu"> <meta name="description" content="A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design. "> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link defer rel="stylesheet" href="/assets/css/scholar-icons.css?62b2ac103a88034e6882a5be5f3e2772"> <link defer rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons&amp;display=swap"> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="/assets/img/touxiang.jpg?68b4199d95528c9129ff55a104244865"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://stibiums.github.io/notes/dsa-ch06/"> <script src="/assets/js/theme.js?a81d82887dd692e91686b43de4542f18"></script> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?5847e5ed4a4568527aa6cfab446049ca" media="none" id="highlight_theme_dark"> <script>
    initTheme();
  </script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"> STIBIUMS_WEB </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">about </a> </li> <li class="nav-item "> <a class="nav-link" href="/blog/">blog </a> </li> <li class="nav-item active"> <a class="nav-link" href="/notes/">notes <span class="sr-only">(current)</span> </a> </li> <li class="nav-item "> <a class="nav-link" href="/projects/">projects </a> </li> <li class="nav-item "> <a class="nav-link" href="/cv/">cv </a> </li> <li class="nav-item"> <button id="search-toggle" title="Search" onclick="openSearchModal()"> <span class="nav-link">ctrl k <i class="ti ti-search"></i></span> </button> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="ti ti-sun-moon" id="light-toggle-system"></i> <i class="ti ti-moon-filled" id="light-toggle-dark"></i> <i class="ti ti-sun-filled" id="light-toggle-light"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5" role="main"> <div class="post"> <header class="post-header"> <h1 class="post-title">数据结构与算法 - 第6章: 树（Tree）</h1> <p class="post-meta"> Created on October 16, 2025 </p> <p class="post-tags"> <i class="fa-solid fa-calendar fa-sm"></i> 2025   ·   <i class="fa-solid fa-hashtag fa-sm"></i> notes   <i class="fa-solid fa-hashtag fa-sm"></i> DSA   ·   <i class="fa-solid fa-tag fa-sm"></i> DSA </p> </header> <article class="post-content"> <div id="markdown-content"> <h2 id="树的概念">树的概念</h2> <h3 id="树的定义">树的定义</h3> <p><strong>树</strong>是包括\(n\)个结点的有限集合\(T\)（\(n \geq 1\)），使得：</p> <ul> <li>有一个根结点</li> <li>除根以外的其它结点被分成\(m\)个（\(m \geq 0\)）不相交的集合\(T_1, T_2, \ldots, T_m\)，而且这些集合的每一个又都是树。树\(T_1, T_2, \ldots, T_m\)称作这个根的<strong>子树</strong> </li> </ul> <p>这是一个<strong>递归定义</strong>。</p> <h3 id="逻辑结构">逻辑结构</h3> <p>包含\(n\)个结点的有穷集合\(K\)（\(n &gt; 0\)），且在\(K\)上定义了一个关系\(N\)，关系\(N\)满足以下条件：</p> <ol> <li> <p>有且仅有一个结点\(k_0 \in K\)，它对于关系\(N\)来说没有前驱。结点\(k_0\)称作树的<strong>根</strong></p> </li> <li> <p>除\(k_0\)外，\(K\)中每个结点对于关系\(N\)来说都有且仅有一个前驱</p> </li> <li> <p>除\(k_0\)外，任何结点\(k \in K\)，存在一结点序列\(k_0, k_1, \ldots, k_s\)，使得\(k_0\)就是树根，且\(k_s = k\)，其中有序对\(\langle k_{i-1}, k_i \rangle \in N\)（\(1 \leq i \leq s\)）。这样的结点序列称为从根到结点\(k\)的一条<strong>路径</strong></p> </li> </ol> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/notes_img/dsa-ch06/tree-basic-structure-480.webp 480w,/assets/img/notes_img/dsa-ch06/tree-basic-structure-800.webp 800w,/assets/img/notes_img/dsa-ch06/tree-basic-structure-1400.webp 1400w," type="image/webp" sizes="95vw"></source> <img src="/assets/img/notes_img/dsa-ch06/tree-basic-structure.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <p>上图展示了树的基本结构，包括根结点、内部结点和叶结点。每个结点所在的层次从根结点（层次0）开始计数。</p> <h3 id="树的基本术语">树的基本术语</h3> <ul> <li> <strong>结点（node）</strong>：树中的数据元素</li> <li> <strong>结点的度（degree）</strong>：结点的子树个数</li> <li> <strong>叶结点（leaf node）</strong>：度为0的结点</li> <li> <strong>分支结点（internal node）</strong>：度不为0的结点</li> <li> <strong>子女（children）</strong>：结点的下层结点</li> <li> <strong>双亲（parent）</strong>：结点的上层结点</li> <li> <strong>兄弟（sibling）</strong>：同一双亲的子女结点</li> <li> <strong>祖先（ancestor）</strong>：从根到该结点路径上的所有结点</li> <li> <strong>子孙（descendant）</strong>：以某结点为根的子树中的所有结点</li> <li> <strong>结点层次（level）</strong>：根结点层次为0，其它结点层次等于双亲层次加1</li> <li> <strong>树的深度/高度（depth/height）</strong>：树中结点的最大层次数加1</li> <li> <strong>树的度（degree of tree）</strong>：树中所有结点度数的最大值</li> <li> <strong>有序树（ordered tree）</strong>：把树结点的子结点按从左到右的次序顺序编号</li> <li> <strong>无序树（unordered tree）</strong>：子结点无明确次序</li> <li> <strong>森林（forest）</strong>：零棵或多棵不相交的树的集合</li> </ul> <p><strong>重要区别</strong>：度为2的有序树并不是二叉树！</p> <ul> <li>第一子结点被删除后，第二子结点自然顶替成为第1子结点</li> <li>度为2并且严格区分左右两个子结点的有序树才是二叉树</li> </ul> <h3 id="森林">森林</h3> <p><strong>森林</strong>（forest）是零棵或多棵不相交的树的集合（通常是有序集合）。</p> <ul> <li>对于树中的每个结点，其子树组成的集合就是森林</li> <li>而加入一个结点作为根，森林就可以转化成一棵树了</li> </ul> <h2 id="森林与二叉树的等价转换">森林与二叉树的等价转换</h2> <h3 id="等价关系">等价关系</h3> <p>树或森林与二叉树<strong>一一对应</strong>：</p> <ul> <li>任何森林都可以用一棵二叉树唯一表达</li> <li>任何二叉树也都唯一对应到一个森林</li> </ul> <h3 id="转换规则">转换规则</h3> <p>树所对应的二叉树中：</p> <ul> <li>一个结点的<strong>左子结点</strong>是它在原来树里的<strong>第一个子结点</strong> </li> <li> <strong>右子结点</strong>是它在原来的树里的<strong>下一个兄弟</strong> </li> </ul> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/notes_img/dsa-ch06/forest-to-binary-tree-480.webp 480w,/assets/img/notes_img/dsa-ch06/forest-to-binary-tree-800.webp 800w,/assets/img/notes_img/dsa-ch06/forest-to-binary-tree-1400.webp 1400w," type="image/webp" sizes="95vw"></source> <img src="/assets/img/notes_img/dsa-ch06/forest-to-binary-tree.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <p>上图展示了森林到二叉树的转换过程。左侧是原始森林（两棵树），右侧是转换后的二叉树。在二叉树中，实线表示左子结点（第一个子结点），虚线表示右兄弟结点。</p> <h3 id="森林到二叉树的转换">森林到二叉树的转换</h3> <p>把森林\(F\)看作树的有序集合，\(F = (T_1, T_2, \ldots, T_n)\)，对应于\(F\)的二叉树\(B(F)\)的定义是：</p> <ul> <li>若\(n = 0\)，则\(B(F)\)为空</li> <li>若\(n &gt; 0\)，则\(B(F)\)的根是\(T_1\)的根\(R_1\)，\(B(F)\)的左子树是\(B(T_{11}, T_{12}, \ldots, T_{1m})\)，其中\(T_{11}, T_{12}, \ldots, T_{1m}\)是\(R_1\)的子树；\(B(F)\)的右子树是\(B(T_2, \ldots, T_n)\)</li> </ul> <p><strong>转换步骤</strong>：</p> <ol> <li> <strong>加线</strong>：在树中所有相邻的兄弟之间加一连线</li> <li> <strong>抹线</strong>：对树中每个结点，除其最左孩子外，抹去该结点与其余孩子间的连线</li> <li> <strong>整理</strong>：以树的根结点为轴心，将整树顺时针转45°</li> </ol> <p><strong>注意</strong>：树转换成的二叉树其右子树一定为空。</p> <h3 id="二叉树到森林的转换">二叉树到森林的转换</h3> <p>设\(B\)是一棵二叉树，\(root\)是\(B\)的根，\(L\)和\(R\)分别是\(root\)的左子树和右子树，则森林\(F(B)\)的定义是：</p> <ul> <li>若\(B\)为空，则\(F(B)\)是空的森林</li> <li>若\(B\)不为空，则\(F(B)\)是一棵树\(T_1\)加上森林\(F(R)\)，其中树\(T_1\)的根为\(root\)，\(root\)的子树为\(F(L)\)</li> </ul> <p><strong>转换步骤</strong>：</p> <ol> <li> <strong>加线</strong>：若\(p\)结点是父结点的左孩子，则将\(p\)的右孩子、右孩子的右孩子……沿分支找到的所有右孩子，都与\(p\)的双亲用线连起来</li> <li> <strong>抹线</strong>：抹掉原二叉树中双亲与右孩子之间的连线</li> <li> <strong>调整</strong>：将结点按层次排列，形成树结构</li> </ol> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/notes_img/dsa-ch06/left-child-right-sibling-480.webp 480w,/assets/img/notes_img/dsa-ch06/left-child-right-sibling-800.webp 800w,/assets/img/notes_img/dsa-ch06/left-child-right-sibling-1400.webp 1400w," type="image/webp" sizes="95vw"></source> <img src="/assets/img/notes_img/dsa-ch06/left-child-right-sibling.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <p>上图展示了”左子结点/右兄弟”表示法的转换关系。左侧是原始树，右侧是对应的二叉树形式。</p> <h2 id="树的抽象数据类型">树的抽象数据类型</h2> <h3 id="树结点的adt">树结点的ADT</h3> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">TreeNode</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">TreeNode</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span><span class="p">);</span>                          <span class="c1">// 构造函数</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="n">TreeNode</span><span class="p">(){};</span>                       <span class="c1">// 析构函数</span>
    <span class="kt">bool</span> <span class="nf">isLeaf</span><span class="p">();</span>                               <span class="c1">// 如果结点是叶，返回true</span>
    <span class="n">T</span> <span class="nf">Value</span><span class="p">();</span>                                   <span class="c1">// 返回结点的值</span>
    <span class="n">TreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="nf">LeftMostChild</span><span class="p">();</span>                <span class="c1">// 返回第一个左孩子</span>
    <span class="n">TreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="nf">RightSibling</span><span class="p">();</span>                 <span class="c1">// 返回右兄弟</span>
    <span class="kt">void</span> <span class="nf">setValue</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;</span><span class="p">);</span>                           <span class="c1">// 设置结点的值</span>
    <span class="kt">void</span> <span class="nf">setChild</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">pointer</span><span class="p">);</span>         <span class="c1">// 设置左子结点</span>
    <span class="kt">void</span> <span class="nf">setSibling</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">pointer</span><span class="p">);</span>       <span class="c1">// 设置右兄弟</span>
    <span class="kt">void</span> <span class="nf">InsertFirst</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">node</span><span class="p">);</span>         <span class="c1">// 以第一个左子结点身份插入结点</span>
    <span class="kt">void</span> <span class="nf">InsertNext</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">node</span><span class="p">);</span>          <span class="c1">// 以右兄弟的身份插入结点</span>
<span class="p">};</span>
</code></pre></div></div> <h3 id="树的adt">树的ADT</h3> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Tree</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">Tree</span><span class="p">();</span>                                      <span class="c1">// 构造函数</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="n">Tree</span><span class="p">();</span>                             <span class="c1">// 析构函数</span>
    <span class="n">TreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">getRoot</span><span class="p">();</span>                      <span class="c1">// 返回树中的根结点</span>
    <span class="kt">void</span> <span class="n">CreateRoot</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">rootValue</span><span class="p">);</span>         <span class="c1">// 创建树中的根结点</span>
    <span class="kt">bool</span> <span class="n">isEmpty</span><span class="p">();</span>                              <span class="c1">// 判断是否为空树</span>
    <span class="n">TreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">Parent</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">current</span><span class="p">);</span>   <span class="c1">// 返回current结点的父结点</span>
    <span class="n">TreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">PrevSibling</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">current</span><span class="p">);</span> <span class="c1">// 返回前一个兄弟结点</span>
    <span class="kt">void</span> <span class="n">DeleteSubTree</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">subroot</span><span class="p">);</span>    <span class="c1">// 删除以subroot为根的子树</span>
    <span class="kt">void</span> <span class="n">RootFirstTraverse</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">root</span><span class="p">);</span>   <span class="c1">// 先根深度优先周游树</span>
    <span class="kt">void</span> <span class="n">RootLastTraverse</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">root</span><span class="p">);</span>    <span class="c1">// 后根深度优先周游树</span>
    <span class="kt">void</span> <span class="n">WidthTraverse</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">root</span><span class="p">);</span>       <span class="c1">// 宽度优先周游树</span>
<span class="p">};</span>
</code></pre></div></div> <h2 id="树森林的周游">树（森林）的周游</h2> <h3 id="深度优先周游">深度优先周游</h3> <h4 id="先根次序preorder">先根次序（Preorder）</h4> <p>若树非空，则遍历方法为：</p> <ol> <li>访问根结点</li> <li>从左到右，依次先根遍历根结点的每一棵子树</li> </ol> <h4 id="后根次序postorder">后根次序（Postorder）</h4> <p>若树非空，则遍历方法为：</p> <ol> <li>从左到右，依次后根遍历根结点的每一棵子树</li> <li>访问根结点</li> </ol> <p><strong>注意</strong>：树没有中根次序周游。</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/notes_img/dsa-ch06/tree-traversal-orders-480.webp 480w,/assets/img/notes_img/dsa-ch06/tree-traversal-orders-800.webp 800w,/assets/img/notes_img/dsa-ch06/tree-traversal-orders-1400.webp 1400w," type="image/webp" sizes="95vw"></source> <img src="/assets/img/notes_img/dsa-ch06/tree-traversal-orders.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <p>上图展示了树的先根遍历和后根遍历结果。先根遍历首先访问根结点，然后递归遍历子树；后根遍历先递归遍历子树，最后访问根结点。</p> <h3 id="周游性质">周游性质</h3> <ul> <li> <strong>按先根次序周游树</strong>正好等于对应二叉树的<strong>前序周游</strong> </li> <li> <strong>按后根次序周游树</strong>正好等于对应二叉树的<strong>中序周游</strong> </li> </ul> <h3 id="先根深度优先周游算法">先根深度优先周游算法</h3> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="kt">void</span> <span class="n">Tree</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">RootFirstTraverse</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">root</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">Visit</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">Value</span><span class="p">());</span>                    <span class="c1">// 访问当前结点</span>
        <span class="n">RootFirstTraverse</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">LeftMostChild</span><span class="p">());</span> <span class="c1">// 周游头一棵树根的子树</span>
        <span class="n">root</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">RightSibling</span><span class="p">();</span>             <span class="c1">// 周游其他的树</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="后根深度优先周游算法">后根深度优先周游算法</h3> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="kt">void</span> <span class="n">Tree</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">RootLastTraverse</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">root</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">RootLastTraverse</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">LeftMostChild</span><span class="p">());</span> <span class="c1">// 周游头一棵树根的子树</span>
        <span class="n">Visit</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">Value</span><span class="p">());</span>                    <span class="c1">// 访问当前结点</span>
        <span class="n">root</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">RightSibling</span><span class="p">();</span>             <span class="c1">// 周游其他的树</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="广度优先周游">广度优先周游</h3> <p><strong>思想</strong>：先访问层数为0的结点；然后从左到右逐个访问层数为1的结点；……；依此类推，直到访问完树中的全部结点。</p> <p><strong>实现</strong>：使用队列数据结构</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="kt">void</span> <span class="n">Tree</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">WidthTraverse</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">queue</span><span class="p">;</span>
    <span class="n">queue</span><span class="o">&lt;</span><span class="n">TreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*&gt;</span> <span class="n">aQueue</span><span class="p">;</span>
    <span class="n">TreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">pointer</span> <span class="o">=</span> <span class="n">root</span><span class="p">;</span>

    <span class="c1">// 森林中所有根结点进入队列</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">pointer</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">aQueue</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">pointer</span><span class="p">);</span>
        <span class="n">pointer</span> <span class="o">=</span> <span class="n">pointer</span><span class="o">-&gt;</span><span class="n">RightSibling</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">aQueue</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
        <span class="n">pointer</span> <span class="o">=</span> <span class="n">aQueue</span><span class="p">.</span><span class="n">front</span><span class="p">();</span>                <span class="c1">// 获得队首元素</span>
        <span class="n">aQueue</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>                            <span class="c1">// 当前结点出队列</span>
        <span class="n">Visit</span><span class="p">(</span><span class="n">pointer</span><span class="o">-&gt;</span><span class="n">Value</span><span class="p">());</span>                 <span class="c1">// 访问当前结点</span>
        <span class="n">pointer</span> <span class="o">=</span> <span class="n">pointer</span><span class="o">-&gt;</span><span class="n">LeftMostChild</span><span class="p">();</span>      <span class="c1">// 指向最左孩子</span>

        <span class="c1">// 当前结点的子结点进队列</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">pointer</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">aQueue</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">pointer</span><span class="p">);</span>
            <span class="n">pointer</span> <span class="o">=</span> <span class="n">pointer</span><span class="o">-&gt;</span><span class="n">RightSibling</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <h2 id="树的链式存储">树的链式存储</h2> <p>树的链式存储有多种表示法：</p> <ol> <li>子结点表表示法</li> <li>动态结点表示法</li> <li>静态”左子结点/右兄弟结点”表示法</li> <li>动态”左子结点/右兄弟结点”表示法</li> <li>父指针表示法</li> </ol> <h3 id="子结点表表示法">子结点表表示法</h3> <p>每个结点包含：</p> <ul> <li>值域</li> <li>父结点指针</li> <li>子结点链表</li> </ul> <p><strong>优点</strong>：</p> <ul> <li>查找孩子个数和结点的值容易</li> <li>树的归并容易（只需一棵树的根添到另一棵树的孩子结点表中即可）</li> </ul> <p><strong>缺点</strong>：</p> <ul> <li>找兄弟结点困难</li> </ul> <h3 id="动态结点表示法">动态结点表示法</h3> <h4 id="指针数组法">指针数组法</h4> <p>每个结点包含：</p> <ul> <li>值域</li> <li>度数域</li> <li>指向子结点的指针数组</li> </ul> <h4 id="指针链表法">指针链表法</h4> <p>每个结点包含：</p> <ul> <li>值域</li> <li>指向第一个子结点的指针</li> <li>指向子结点链表的指针</li> </ul> <h3 id="静态左子结点右兄弟结点表示法">静态”左子结点/右兄弟结点”表示法</h3> <p>使用数组存储结点，每个结点包含：</p> <ul> <li>值域</li> <li>父结点索引</li> <li>左子结点索引</li> <li>右兄弟结点索引</li> </ul> <p><strong>优点</strong>：</p> <ul> <li>比子结点表表示法空间效率更高</li> <li>结点数组中的每个结点仅需要固定大小的存储空间</li> <li>树的合并简单（如果两棵树在同一个数组中）</li> </ul> <h3 id="动态左子结点右兄弟结点二叉链表表示法">动态”左子结点/右兄弟结点”二叉链表表示法</h3> <p><strong>本质</strong>：使用二叉树来替换树</p> <p><strong>基本思想</strong>：</p> <ul> <li>左孩子在树中是结点的最左子结点</li> <li>右子结点是结点原来的右侧兄弟结点</li> <li>根的右链就是森林中每棵树的根结点</li> </ul> <p><strong>私有成员变量</strong>：</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nl">private:</span>
    <span class="n">T</span> <span class="n">m_Value</span><span class="p">;</span>                   <span class="c1">// 树结点的值</span>
    <span class="n">TreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">pChild</span><span class="p">;</span>         <span class="c1">// 左孩子</span>
    <span class="n">TreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">pSibling</span><span class="p">;</span>       <span class="c1">// 右兄弟</span>
</code></pre></div></div> <p><strong>成员函数实现示例</strong>：</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="kt">bool</span> <span class="n">TreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">isLeaf</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">pChild</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="kt">void</span> <span class="n">TreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">InsertFirst</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">node</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">pChild</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">node</span><span class="o">-&gt;</span><span class="n">pSibling</span> <span class="o">=</span> <span class="n">pChild</span><span class="p">;</span>
        <span class="n">pChild</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">pChild</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="父指针表示法">父指针表示法</h3> <p>在某些应用中，只需要知道父结点情况，因此每个结点只需要保存一个指向其父结点的指针域。</p> <p><strong>特点</strong>：</p> <ul> <li>用数组存储树所有结点</li> <li>在每个结点中附设一个”指针”指示其父结点的位置</li> <li>由于树中每一个结点的父指针是唯一的，所以父指针表示法可以唯一表示一棵树</li> </ul> <p><strong>基本操作</strong>：</p> <ul> <li> <strong>查询结点的根</strong>：从一个结点出发找出一条向上延伸到达根的祖先路径 — \(O(k)\)，\(k\)为树高</li> <li> <strong>判断两个结点是否在同一棵树</strong>：两个结点根结点相同，它们一定在同一棵树中</li> </ul> <p><strong>优点</strong>：</p> <ul> <li>寻找父结点只需\(O(k)\)时间</li> <li>求树根结点非常方便</li> </ul> <p><strong>缺点</strong>：</p> <ul> <li>寻兄弟节点麻烦，需要查询整个树结构</li> <li>没有标识节点的左右次序，适合无序树的情况</li> </ul> <h2 id="并查集union-find">并查集（Union-Find）</h2> <h3 id="基本概念">基本概念</h3> <p><strong>并查集</strong>是一种特殊集合，由不相交子集构成。</p> <p><strong>基本操作</strong>：</p> <ul> <li> <strong>Find</strong>：判断两个结点是否在同一个集合中</li> <li> <strong>Union</strong>：归并两个集合</li> </ul> <p>并查集可用于求解<strong>等价类问题</strong>。</p> <h3 id="等价关系-1">等价关系</h3> <p>一个具有\(n\)个元素的集合\(S\)，另有一个定义在集合\(S\)上的\(r\)个关系的关系集合\(R\)。\(x, y, z\)表示集合中的元素。</p> <p>若关系\(R\)是一个<strong>等价关系</strong>，当且仅当如下条件为真时成立：</p> <ol> <li>对于所有的\(x\)，有\((x, x) \in R\)（即关系是<strong>自反的</strong>）</li> <li>当且仅当\((x, y) \in R\)时\((y, x) \in R\)（即关系是<strong>对称的</strong>）</li> <li>若\((x, y) \in R\)且\((y, z) \in R\)，则有\((x, z) \in R\)（即关系是<strong>传递的</strong>）</li> </ol> <p>如果\((x, y) \in R\)，则元素\(x\)和\(y\)是等价的。</p> <h3 id="并查算法">并查算法</h3> <p><strong>初始状态</strong>：每个元素都在独立的只包含一个结点的树中，而它自己就是根结点。</p> <p><strong>算法流程</strong>：</p> <ol> <li>使用<code class="language-plaintext highlighter-rouge">Different</code>函数，判断一个等价对中的两个元素是否在同一棵树中 <ul> <li>如果是，由于它们已经在同一个等价类中，不需要作变动</li> <li>否则两个等价类可以用<code class="language-plaintext highlighter-rouge">Union</code>函数归并</li> </ul> </li> </ol> <h3 id="树结点的adt-1">树结点的ADT</h3> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">ParTreeNode</span> <span class="p">{</span>
<span class="nl">private:</span>
    <span class="n">T</span> <span class="n">value</span><span class="p">;</span>                     <span class="c1">// 结点的值</span>
    <span class="n">ParTreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">parent</span><span class="p">;</span>      <span class="c1">// 父结点指针</span>
    <span class="kt">int</span> <span class="n">nCount</span><span class="p">;</span>                  <span class="c1">// 以此结点为根的子树的总结点个数</span>
<span class="nl">public:</span>
    <span class="n">ParTreeNode</span><span class="p">();</span>               <span class="c1">// 构造函数</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="n">ParTreeNode</span><span class="p">(){};</span>    <span class="c1">// 析构函数</span>
    <span class="n">T</span> <span class="nf">getValue</span><span class="p">();</span>                <span class="c1">// 返回结点的值</span>
    <span class="kt">void</span> <span class="nf">setValue</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">val</span><span class="p">);</span> <span class="c1">// 设置结点的值</span>
    <span class="n">ParTreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="nf">getParent</span><span class="p">();</span> <span class="c1">// 返回父结点指针</span>
    <span class="kt">void</span> <span class="nf">setParent</span><span class="p">(</span><span class="n">ParTreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">par</span><span class="p">);</span> <span class="c1">// 设置父结点指针</span>
    <span class="kt">int</span> <span class="nf">getCount</span><span class="p">();</span>              <span class="c1">// 返回结点数目</span>
    <span class="kt">void</span> <span class="nf">setCount</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="n">count</span><span class="p">);</span> <span class="c1">// 设置结点数目</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="树的adt-1">树的ADT</h3> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">ParTree</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">ParTreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">array</span><span class="p">;</span>       <span class="c1">// 存储树结点的数组</span>
    <span class="kt">int</span> <span class="n">Size</span><span class="p">;</span>                    <span class="c1">// 数组大小</span>
    <span class="n">ParTree</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="n">size</span><span class="p">);</span>     <span class="c1">// 构造函数</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="n">ParTree</span><span class="p">();</span>          <span class="c1">// 析构函数</span>

    <span class="c1">// 查找node结点所属子树的根结点</span>
    <span class="n">ParTreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">Find</span><span class="p">(</span><span class="n">ParTreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">node</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

    <span class="c1">// 把下标为i，j的结点所属子树合并</span>
    <span class="kt">void</span> <span class="n">Union</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">int</span> <span class="n">j</span><span class="p">);</span>

    <span class="c1">// 判定下标为i，j的结点是否在一棵树中</span>
    <span class="kt">bool</span> <span class="n">Different</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">int</span> <span class="n">j</span><span class="p">);</span>
<span class="p">};</span>
</code></pre></div></div> <h3 id="find操作">Find操作</h3> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="n">ParTreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">ParTree</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">Find</span><span class="p">(</span><span class="n">ParTreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">node</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
    <span class="n">ParTreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">pointer</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">pointer</span><span class="o">-&gt;</span><span class="n">getParent</span><span class="p">()</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
        <span class="n">pointer</span> <span class="o">=</span> <span class="n">pointer</span><span class="o">-&gt;</span><span class="n">getParent</span><span class="p">();</span>
    <span class="k">return</span> <span class="n">pointer</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="different操作">Different操作</h3> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="kt">bool</span> <span class="n">ParTree</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">Different</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">int</span> <span class="n">j</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">ParTreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">pointeri</span> <span class="o">=</span> <span class="n">Find</span><span class="p">(</span><span class="o">&amp;</span><span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span> <span class="c1">// 找到结点i的根</span>
    <span class="n">ParTreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">pointerj</span> <span class="o">=</span> <span class="n">Find</span><span class="p">(</span><span class="o">&amp;</span><span class="n">array</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span> <span class="c1">// 找到结点j的根</span>
    <span class="k">return</span> <span class="n">pointeri</span> <span class="o">!=</span> <span class="n">pointerj</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="union操作重量权衡合并规则">Union操作（重量权衡合并规则）</h3> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="kt">void</span> <span class="n">ParTree</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">Union</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">int</span> <span class="n">j</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">ParTreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">pointeri</span> <span class="o">=</span> <span class="n">Find</span><span class="p">(</span><span class="o">&amp;</span><span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="n">ParTreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">pointerj</span> <span class="o">=</span> <span class="n">Find</span><span class="p">(</span><span class="o">&amp;</span><span class="n">array</span><span class="p">[</span><span class="n">j</span><span class="p">]);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">pointeri</span> <span class="o">!=</span> <span class="n">pointerj</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">pointeri</span><span class="o">-&gt;</span><span class="n">getCount</span><span class="p">()</span> <span class="o">&gt;=</span> <span class="n">pointerj</span><span class="o">-&gt;</span><span class="n">getCount</span><span class="p">())</span> <span class="p">{</span>
            <span class="n">pointerj</span><span class="o">-&gt;</span><span class="n">setParent</span><span class="p">(</span><span class="n">pointeri</span><span class="p">);</span>
            <span class="n">pointeri</span><span class="o">-&gt;</span><span class="n">setCount</span><span class="p">(</span><span class="n">pointeri</span><span class="o">-&gt;</span><span class="n">getCount</span><span class="p">()</span> <span class="o">+</span> <span class="n">pointerj</span><span class="o">-&gt;</span><span class="n">getCount</span><span class="p">());</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">pointeri</span><span class="o">-&gt;</span><span class="n">setParent</span><span class="p">(</span><span class="n">pointerj</span><span class="p">);</span>
            <span class="n">pointerj</span><span class="o">-&gt;</span><span class="n">setCount</span><span class="p">(</span><span class="n">pointeri</span><span class="o">-&gt;</span><span class="n">getCount</span><span class="p">()</span> <span class="o">+</span> <span class="n">pointerj</span><span class="o">-&gt;</span><span class="n">getCount</span><span class="p">());</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="重量权衡合并规则weighted-union-rule">重量权衡合并规则（Weighted Union Rule）</h3> <p>将结点较少树的根结点指向结点较多树的根结点，这可以把树的整体深度限制在\(O(\log n)\)。</p> <p><strong>原理</strong>：</p> <ul> <li>当处理完\(n\)个元素后，任何结点的深度最多只会增加\(\log n\)次</li> <li>每次归并，最大高度最多增加1</li> <li>而结点个数成倍增加</li> </ul> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/notes_img/dsa-ch06/union-find-example-480.webp 480w,/assets/img/notes_img/dsa-ch06/union-find-example-800.webp 800w,/assets/img/notes_img/dsa-ch06/union-find-example-1400.webp 1400w," type="image/webp" sizes="95vw"></source> <img src="/assets/img/notes_img/dsa-ch06/union-find-example.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <p>上图展示了并查集的基本操作流程。从初始状态（每个元素独立）开始，通过一系列Union操作，逐步将元素合并到不同的集合中。使用重量权衡规则可以保持树的平衡性。</p> <h3 id="路径压缩算法">路径压缩算法</h3> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="n">ParTreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">ParTree</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">FindPC</span><span class="p">(</span><span class="n">ParTreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">node</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">getParent</span><span class="p">()</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">node</span><span class="p">;</span>
    <span class="n">node</span><span class="o">-&gt;</span><span class="n">setParent</span><span class="p">(</span><span class="n">FindPC</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">getParent</span><span class="p">()));</span>
    <span class="k">return</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">getParent</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div> <p><strong>思想</strong>：</p> <ul> <li>查找\(X\)时，设\(X\)最终到达根\(R\)</li> <li>顺着由\(X\)到\(R\)的路径把每个结点的父指针域均设置为直接指向\(R\)</li> <li>产生极浅树</li> </ul> <h3 id="复杂度分析">复杂度分析</h3> <p>假设同时使用了”重量权衡合并规则”和”路径压缩”：</p> <table> <thead> <tr> <th>操作</th> <th>平均情况</th> <th>最坏情况</th> </tr> </thead> <tbody> <tr> <td>Space</td> <td>\(O(n)\)</td> <td>\(O(n)\)</td> </tr> <tr> <td>Find</td> <td>\(O(\alpha(n))\)</td> <td>\(O(\alpha(n))\)</td> </tr> <tr> <td>Union</td> <td>\(O(\alpha(n))\)</td> <td>\(O(\alpha(n))\)</td> </tr> </tbody> </table> <p>其中\(O(\alpha(n))\)是一个增长非常缓慢的Ackermann函数，可以认为\(\alpha(n)\)是一个小于5的常数。</p> <h2 id="树的顺序存储">树的顺序存储</h2> <p>按照树遍历的次序进行节点存储：</p> <ol> <li>带右链的先根次序表示法</li> <li>带双标记位的先根次序表示法</li> <li>带度数的后根次序表示法</li> <li>带双标记的层次次序表示</li> </ol> <p>关键：如何还原出树的结构</p> <h3 id="带右链的先根次序表示法">带右链的先根次序表示法</h3> <p><strong>先根遍历特点</strong>：</p> <ul> <li>任何结点的子树的所有结点都直接跟在该结点之后</li> <li>每棵子树的所有结点都聚集在一起，中间不会插入别的结点</li> <li>任何一个分支结点后面跟的都是它的第一个子结点（如果存在的话）</li> </ul> <p><strong>结点结构</strong>：</p> <ul> <li> <code class="language-plaintext highlighter-rouge">info</code>：结点数据</li> <li> <code class="language-plaintext highlighter-rouge">ltag</code>：左标记（1位） <ul> <li>0：有子结点</li> <li>1：没有子结点</li> </ul> </li> <li> <code class="language-plaintext highlighter-rouge">rlink</code>：右指针，指向下一个兄弟</li> </ul> <p><strong>特点</strong>：</p> <ul> <li>与二叉链表相比，用<code class="language-plaintext highlighter-rouge">ltag</code>代替<code class="language-plaintext highlighter-rouge">llink</code>，占用存储单元少，但并不丢失信息</li> <li>可以从结点的次序和<code class="language-plaintext highlighter-rouge">ltag</code>的值完全推知<code class="language-plaintext highlighter-rouge">llink</code> </li> </ul> <h3 id="带双标记位的先根次序表示法">带双标记位的先根次序表示法</h3> <p>事实上，带右链的先根次序表示法中<code class="language-plaintext highlighter-rouge">rlink</code>也不是必需的，以1位的<code class="language-plaintext highlighter-rouge">rtag</code>就足以表示出整个森林的结构信息。</p> <p><strong>结点结构</strong>：</p> <ul> <li> <code class="language-plaintext highlighter-rouge">info</code>：结点数据</li> <li> <code class="language-plaintext highlighter-rouge">ltag</code>：左标记 <ul> <li>0：有子结点</li> <li>1：无子结点</li> </ul> </li> <li> <code class="language-plaintext highlighter-rouge">rtag</code>：右标记 <ul> <li>0：有兄弟</li> <li>1：无兄弟</li> </ul> </li> </ul> <p><strong>重要性质</strong>：有兄弟节点与无孩子节点一一对应，满足栈特性！</p> <p><strong>规则</strong>：”有兄弟就入栈，无孩子就出栈”</p> <ul> <li>扫描到一个<code class="language-plaintext highlighter-rouge">rtag</code>为0的结点就将它进栈</li> <li>扫描到一个<code class="language-plaintext highlighter-rouge">ltag</code>为1的结点就从栈顶弹出一个结点，并为其设置<code class="language-plaintext highlighter-rouge">rlink</code>，下一个要读出的节点即为其兄弟节点</li> </ul> <h3 id="构造左子结点右兄弟树算法">构造左子结点右兄弟树算法</h3> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="n">Tree</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">Tree</span><span class="p">(</span><span class="n">DualTagTreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">nodeArray</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">stack</span><span class="p">;</span>
    <span class="n">stack</span><span class="o">&lt;</span><span class="n">TreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*&gt;</span> <span class="n">aStack</span><span class="p">;</span>
    <span class="n">TreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">pointer</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">;</span>
    <span class="n">root</span> <span class="o">=</span> <span class="n">pointer</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">count</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">pointer</span><span class="o">-&gt;</span><span class="n">setValue</span><span class="p">(</span><span class="n">nodeArray</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">info</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">nodeArray</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">rtag</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>          <span class="c1">// 有兄弟，则压栈</span>
            <span class="n">aStack</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">pointer</span><span class="p">);</span>
        <span class="k">else</span>
            <span class="n">pointer</span><span class="o">-&gt;</span><span class="n">setSibling</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>        <span class="c1">// 无兄弟，兄弟域设为空</span>

        <span class="n">TreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;*</span> <span class="n">temppointer</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TreeNode</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">nodeArray</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">ltag</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>          <span class="c1">// 有孩子，则设为孩子</span>
            <span class="n">pointer</span><span class="o">-&gt;</span><span class="n">setChild</span><span class="p">(</span><span class="n">temppointer</span><span class="p">);</span>
        <span class="k">else</span> <span class="p">{</span>                                <span class="c1">// 无孩子则出栈</span>
            <span class="n">pointer</span><span class="o">-&gt;</span><span class="n">setChild</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>
            <span class="n">pointer</span> <span class="o">=</span> <span class="n">aStack</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
            <span class="n">pointer</span><span class="o">-&gt;</span><span class="n">setSibling</span><span class="p">(</span><span class="n">temppointer</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="n">pointer</span> <span class="o">=</span> <span class="n">temppointer</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">pointer</span><span class="o">-&gt;</span><span class="n">setValue</span><span class="p">(</span><span class="n">nodeArray</span><span class="p">[</span><span class="n">count</span> <span class="o">-</span> <span class="mi">1</span><span class="p">].</span><span class="n">info</span><span class="p">);</span>
    <span class="n">pointer</span><span class="o">-&gt;</span><span class="n">setChild</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>
    <span class="n">pointer</span><span class="o">-&gt;</span><span class="n">setSibling</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="带度数的后根次序表示法">带度数的后根次序表示法</h3> <p>结点按后根次序顺序存储，结点形式为：<code class="language-plaintext highlighter-rouge">[info, degree]</code></p> <ul> <li> <code class="language-plaintext highlighter-rouge">info</code>：结点的数据</li> <li> <code class="language-plaintext highlighter-rouge">degree</code>：结点的度数</li> </ul> <p><strong>转换思路</strong>：</p> <ul> <li>度数为零的结点是叶子结点（也可看作一棵子树）</li> <li>当遇到度数非零（设为\(k\)）的结点时，则排在该结点之前且离它最近的\(k\)个子树的根就是该结点的\(k\)个子结点</li> </ul> <p><strong>实现</strong>：利用栈</p> <ul> <li>遇到零度顶点就入栈</li> <li>遇到非零\(k\)度顶点就从栈中弹出\(k\)个节点作为其子节点，然后将该非零顶点入栈</li> <li>持续扫描，直至序列扫描完毕</li> </ul> <h3 id="带双标记的层次次序表示">带双标记的层次次序表示</h3> <p><strong>结点结构</strong>：</p> <ul> <li> <code class="language-plaintext highlighter-rouge">info</code>：结点数据</li> <li> <code class="language-plaintext highlighter-rouge">ltag</code>：左标记 <ul> <li>0：有左孩子</li> <li>1：无左孩子</li> </ul> </li> <li> <code class="language-plaintext highlighter-rouge">rtag</code>：右标记 <ul> <li>0：有下一个兄弟（下一个节点即为其兄弟节点）</li> <li>1：无兄弟节点</li> </ul> </li> </ul> <p><strong>重要性质</strong>：有孩子节点与无兄弟节点一一对应，满足队列特性！</p> <p><strong>规则</strong>：”有孩子就入队列，无右兄弟就出队列”</p> <ul> <li>如果结点的<code class="language-plaintext highlighter-rouge">ltag</code>值为1，则置其<code class="language-plaintext highlighter-rouge">llink</code>为空；当结点的<code class="language-plaintext highlighter-rouge">ltag</code>为0时，该结点入队列</li> <li>如果结点的<code class="language-plaintext highlighter-rouge">rtag</code>值为0，那么其后的结点\(y\)就是其右兄弟</li> <li>否则，如果结点的<code class="language-plaintext highlighter-rouge">rtag</code>值为1，则<code class="language-plaintext highlighter-rouge">rlink</code>为空，此时出队列\(x\)，并将\(x\)的<code class="language-plaintext highlighter-rouge">llink</code>指向序列中后续结点\(y\)即可</li> </ul> <h2 id="k叉树">K叉树</h2> <h3 id="定义">定义</h3> <p><strong>K叉树</strong>（K-ary Tree）的结点有\(K\)个有序子结点。</p> <p><strong>特点</strong>：</p> <ul> <li>不同于树，K叉树的结点有\(K\)个子结点，子结点数目是固定的</li> <li>相对来说容易实现</li> </ul> <h3 id="特殊k叉树">特殊K叉树</h3> <ul> <li> <strong>满K叉树</strong>：与满二叉树类似</li> <li> <strong>完全K叉树</strong>：与完全二叉树类似</li> </ul> <p><strong>性质</strong>：</p> <ul> <li>二叉树的许多性质可以推广到K叉树</li> <li>也可以把完全K叉树存储在一个数组中</li> </ul> <hr> <h2 id="本章小结">本章小结</h2> <h3 id="主要内容">主要内容</h3> <ol> <li> <p><strong>树的概念</strong></p> <ul> <li>树的递归定义</li> <li>基本术语</li> <li>森林的概念</li> </ul> </li> <li> <p><strong>森林与二叉树的转换</strong></p> <ul> <li>一一对应关系</li> <li>转换算法（加线、抹线、整理）</li> </ul> </li> <li> <p><strong>树的周游</strong></p> <ul> <li>深度优先（先根、后根）</li> <li>广度优先（层次遍历）</li> <li>与二叉树遍历的对应关系</li> </ul> </li> <li> <p><strong>树的存储结构</strong></p> <ul> <li>链式存储（多种表示法）</li> <li>顺序存储（多种表示法）</li> </ul> </li> <li> <p><strong>并查集</strong></p> <ul> <li>等价关系</li> <li>Union和Find操作</li> <li>重量权衡合并规则</li> <li>路径压缩优化</li> </ul> </li> <li> <p><strong>K叉树</strong></p> <ul> <li>定义和性质</li> <li>满K叉树和完全K叉树</li> </ul> </li> </ol> <h3 id="重要结论">重要结论</h3> <ol> <li>树的左子结点/右兄弟表示法本质上就是二叉树</li> <li>森林与二叉树可以相互转换</li> <li>树的先根遍历对应二叉树的前序遍历</li> <li>树的后根遍历对应二叉树的中序遍历</li> <li>并查集使用重量权衡+路径压缩可达到近似常数时间复杂度</li> </ol> <h3 id="思考题">思考题</h3> <ol> <li> <p><strong>叶结点数公式</strong>：若某树有\(n_1\)个度数为1的结点，有\(n_2\)个度数为2的结点，……有\(n_m\)个度数为\(m\)的结点，试问它有多少个叶结点？</p> <p>设叶子结点数为\(n_0\)，树的结点数为\(N\)：</p> \[N = n_0 + n_1 + n_2 + \cdots + n_m\] <p>又等于所有节点的分支数（或度数）\(+1\)：</p> \[N = n_1 + 2n_2 + 3n_3 + \cdots + mn_m + 1\] <p>因此：</p> \[n_0 = n_2 + 2n_3 + 3n_4 + \cdots + (m-1)n_m + 1\] </li> <li> <p><strong>任何一棵二叉树的叶结点在先序、中序和后序的遍历序列中的相对次序不发生改变</strong></p> </li> <li> <p><strong>某二叉树的先根序列和后根序列正好相反，则该二叉树一定是</strong>：</p> <ul> <li>树的高度等于其结点数减1</li> <li>任一结点都只有左子结点或只有右子结点</li> </ul> </li> </ol> <hr> <p><em>本笔记基于北京大学《数据结构与算法》第六章内容整理</em></p> </div> </article> <br> <hr> <br> <ul class="list-disc pl-8"></ul> <h2 class="text-3xl font-semibold mb-4 mt-12">Enjoy Reading This Article?</h2> <p class="mb-2">Here are some more articles you might like to read next:</p> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2025/09/08/notesof_ML/">notes of ML</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2025/09/08/notesofvci/">notes of VCI</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2025/09/08/notesofaip/">notes of AIP</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2025/09/08/notesof_aimath/">notes of AI Math Fundamentals</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2025/09/08/notesof_ICS/">notes of ICS</a> </li> </div> </div> <footer class="fixed-bottom" role="contentinfo"> <div class="container mt-0"> © Copyright 2025 stibiums liu. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. Photos from <a href="https://unsplash.com" target="_blank" rel="external nofollow noopener">Unsplash</a>. Last updated: October 21, 2025. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@5.0.0/imagesloaded.pkgd.min.js" integrity="sha256-htrLFfZJ6v5udOG+3kNLINIKh2gvoKqwEhHYfTTMICc=" crossorigin="anonymous"></script> <script defer src="/assets/js/masonry.js?a0db7e5d5c70cc3252b3138b0c91dcaf" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?85ddb88934d28b74e78031fd54cf8308"></script> <script src="/assets/js/no_defer.js?2781658a0a2b13ed609542042a859126"></script> <script defer src="/assets/js/common.js?e0514a05c5c95ac1a93a8dfd5249b92e"></script> <script defer src="/assets/js/copy_code.js?c8a01c11a92744d44b093fc3bda915df" type="text/javascript"></script> <script defer src="/assets/js/jupyter_new_tab.js?d9f17b6adc2311cbabd747f4538bb15f"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js" integrity="sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI=" crossorigin="anonymous"></script> <script src="/assets/js/mathjax-setup.js?58fdb075e5aa03fbb8617845abde746c"></script> <script defer src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6" crossorigin="anonymous"></script> <script defer src="/assets/js/progress-bar.js?2f30e0e6801ea8f5036fa66e1ab0a71a" type="text/javascript"></script> <script src="/assets/js/vanilla-back-to-top.min.js?f40d453793ff4f64e238e420181a1d17"></script> <script>
    addBackToTop();
  </script> <script type="module" src="/assets/js/search/ninja-keys.min.js?a3446f084dcaecc5f75aa1757d087dcf"></script> <ninja-keys hidebreadcrumbs noautoloadmdicons placeholder="Type to start searching"></ninja-keys> <script src="/assets/js/search-setup.js?6c304f7b1992d4b60f7a07956e52f04a"></script> <script src="/assets/js/search-data.js"></script> <script src="/assets/js/shortcut-key.js?6f508d74becd347268a7f822bca7309d"></script> </body> </html>