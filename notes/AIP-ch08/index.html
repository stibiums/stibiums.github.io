<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> 人工智能中的编程 - 第8章: Pybind与单元测试（Pybind and Unit Test） | STIBIUMS_WEB </title> <meta name="author" content="stibiums liu"> <meta name="description" content="A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design. "> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link defer rel="stylesheet" href="/assets/css/scholar-icons.css?62b2ac103a88034e6882a5be5f3e2772"> <link defer rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons&amp;display=swap"> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="/assets/img/touxiang.jpg?68b4199d95528c9129ff55a104244865"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://stibiums.github.io/notes/AIP-ch08/"> <script src="/assets/js/theme.js?a81d82887dd692e91686b43de4542f18"></script> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?5847e5ed4a4568527aa6cfab446049ca" media="none" id="highlight_theme_dark"> <script>
    initTheme();
  </script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"> STIBIUMS_WEB </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">about </a> </li> <li class="nav-item "> <a class="nav-link" href="/blog/">blog </a> </li> <li class="nav-item active"> <a class="nav-link" href="/notes/">notes <span class="sr-only">(current)</span> </a> </li> <li class="nav-item "> <a class="nav-link" href="/projects/">projects </a> </li> <li class="nav-item "> <a class="nav-link" href="/cv/">cv </a> </li> <li class="nav-item"> <button id="search-toggle" title="Search" onclick="openSearchModal()"> <span class="nav-link">ctrl k <i class="ti ti-search"></i></span> </button> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="ti ti-sun-moon" id="light-toggle-system"></i> <i class="ti ti-moon-filled" id="light-toggle-dark"></i> <i class="ti ti-sun-filled" id="light-toggle-light"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5" role="main"> <div class="post"> <header class="post-header"> <h1 class="post-title">人工智能中的编程 - 第8章: Pybind与单元测试（Pybind and Unit Test）</h1> <p class="post-meta"> Created on October 17, 2025 </p> <p class="post-tags"> <i class="fa-solid fa-calendar fa-sm"></i> 2025   ·   <i class="fa-solid fa-hashtag fa-sm"></i> notes   <i class="fa-solid fa-hashtag fa-sm"></i> AIP   ·   <i class="fa-solid fa-tag fa-sm"></i> AIP </p> </header> <article class="post-content"> <div id="markdown-content"> <h2 id="python与cudac的互补性">Python与CUDA/C++的互补性</h2> <h3 id="python和c各自的优势">Python和C++各自的优势</h3> <p>现代深度学习框架普遍采用Python和CUDA/C++混合编程的架构：</p> <p><strong>Python的特点</strong>：</p> <ul> <li>高级通用编程语言</li> <li>专注于提高生产力和代码可读性</li> <li>核心语法简洁，标准库功能丰富</li> <li>提供快速开发和灵活性</li> </ul> <p><strong>CUDA/C++的特点</strong>：</p> <ul> <li>提供高效的计算性能</li> <li>底层硬件控制能力强</li> <li>适合计算密集型任务</li> </ul> <p><strong>最佳实践</strong>：</p> <ul> <li>Python层：模型定义、数据处理、实验流程</li> <li>C++/CUDA层：高性能算子、底层优化</li> </ul> <h2 id="pybind11简介">Pybind11简介</h2> <h3 id="什么是pybind11">什么是Pybind11</h3> <p><strong>pybind11</strong>是一个轻量级的<strong>仅头文件（header-only）库</strong>，用于在Python和C++之间相互暴露类型。</p> <p><strong>特点</strong>：</p> <ul> <li>类似于Boost.Python库，但更轻量</li> <li>Boost.Python几乎兼容所有C++编译器，但体积过大</li> <li>pybind11是Boost.Python的精简自包含版本</li> <li>PyTorch等主流深度学习框架广泛使用</li> </ul> <p><strong>作者和应用</strong>：</p> <ul> <li>作者：Wenzel Jakob</li> <li>代表性应用：Mitsuba、Instant Meshes（SGP软件奖获得者）、PBRT</li> </ul> <h3 id="安装pybind11">安装Pybind11</h3> <p><strong>方法1：直接下载源码</strong></p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git clone https://github.com/pybind/pybind11.git
</code></pre></div></div> <p>然后添加头文件目录到项目中。</p> <p><strong>方法2：使用pip安装</strong></p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pip <span class="nb">install </span>pybind11
</code></pre></div></div> <p><strong>注意</strong>：如果已安装PyTorch，pybind11通常已经包含在内，可用于扩展PyTorch。</p> <h2 id="pybind11基础使用">Pybind11基础使用</h2> <h3 id="第一个pybind示例">第一个Pybind示例</h3> <p><strong>C++代码</strong>：</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;pybind11/pybind11.h&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">add</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">int</span> <span class="n">j</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">i</span> <span class="o">+</span> <span class="n">j</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">PYBIND11_MODULE</span><span class="p">(</span><span class="n">example</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">m</span><span class="p">.</span><span class="n">def</span><span class="p">(</span><span class="s">"add"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">add</span><span class="p">,</span> <span class="s">"A function that adds two numbers"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <p><strong>关键要点</strong>：</p> <ul> <li>包含头文件<code class="language-plaintext highlighter-rouge">pybind11/pybind11.h</code> </li> <li>使用<code class="language-plaintext highlighter-rouge">PYBIND11_MODULE</code>宏定义模块</li> <li>“example”是Python模块的名称</li> <li> <code class="language-plaintext highlighter-rouge">m.def</code>用于绑定C++函数到Python</li> </ul> <h3 id="使用cmake编译">使用CMake编译</h3> <p><strong>基本CMakeLists.txt配置</strong>：</p> <div class="language-cmake highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cmake_minimum_required</span><span class="p">(</span>VERSION 3.12<span class="p">)</span>
<span class="nb">project</span><span class="p">(</span>cmake_example LANGUAGES CUDA CXX C<span class="p">)</span>  <span class="c1"># CUDA支持</span>
<span class="nb">set</span><span class="p">(</span>CMAKE_CXX_STANDARD 11<span class="p">)</span>  <span class="c1"># C++11支持</span>
<span class="nb">set</span><span class="p">(</span>CMAKE_POSITION_INDEPENDENT_CODE ON<span class="p">)</span>

<span class="nb">add_subdirectory</span><span class="p">(</span>pybind11<span class="p">)</span>
<span class="nf">pybind11_add_module</span><span class="p">(</span>cmake_example src/main.cpp<span class="p">)</span>  <span class="c1"># 所有cpp文件</span>
</code></pre></div></div> <p><strong>构建步骤</strong>：</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">mkdir </span>build
<span class="nb">cd </span>build
cmake ..
cmake <span class="nt">--build</span> <span class="nb">.</span> <span class="nt">--config</span> Release <span class="nt">--target</span> check
</code></pre></div></div> <p><strong>添加包含目录和源文件</strong>：</p> <div class="language-cmake highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 添加包含目录</span>
<span class="nb">set</span><span class="p">(</span>your_library_path <span class="s2">"</span><span class="si">${</span><span class="nv">PROJECT_SOURCE_DIR</span><span class="si">}</span><span class="s2">/external/library"</span><span class="p">)</span>
<span class="nb">include_directories</span><span class="p">(</span><span class="si">${</span><span class="nv">your_library_path</span><span class="si">}</span><span class="p">)</span>

<span class="c1"># 查找所有源文件</span>
<span class="nb">file</span><span class="p">(</span>GLOB src
    <span class="s2">"</span><span class="si">${</span><span class="nv">PROJECT_SOURCE_DIR</span><span class="si">}</span><span class="s2">/*.cu"</span>
    <span class="s2">"</span><span class="si">${</span><span class="nv">PROJECT_SOURCE_DIR</span><span class="si">}</span><span class="s2">/*.cpp"</span><span class="p">)</span>

<span class="c1"># 添加可执行文件</span>
<span class="nb">add_executable</span><span class="p">(</span>example_exec <span class="si">${</span><span class="nv">src</span><span class="si">}</span><span class="p">)</span>
</code></pre></div></div> <h2 id="绑定c类">绑定C++类</h2> <h3 id="类的绑定示例">类的绑定示例</h3> <p><strong>C++类定义</strong>：</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span>
<span class="k">class</span> <span class="nc">Pet</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">Pet</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">name</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">weights</span><span class="p">)</span>
        <span class="o">:</span> <span class="n">name</span><span class="p">(</span><span class="n">name</span><span class="p">),</span> <span class="n">weights</span><span class="p">(</span><span class="n">weights</span><span class="p">)</span> <span class="p">{}</span>

    <span class="kt">void</span> <span class="nf">setName</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">name_</span><span class="p">)</span> <span class="p">{</span> <span class="n">name</span> <span class="o">=</span> <span class="n">name_</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">getName</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">name</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">getWeights</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">weights</span><span class="p">;</span> <span class="p">}</span>

<span class="k">protected</span><span class="o">:</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">weights</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div> <p><strong>Pybind绑定代码</strong>：</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;pybind11/pybind11.h&gt;</span><span class="cp">
</span>
<span class="k">namespace</span> <span class="n">py</span> <span class="o">=</span> <span class="n">pybind11</span><span class="p">;</span>

<span class="n">PYBIND11_MODULE</span><span class="p">(</span><span class="n">example</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">py</span><span class="o">::</span><span class="n">class_</span><span class="o">&lt;</span><span class="n">Pet</span><span class="o">&gt;</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">"Pet"</span><span class="p">)</span>
        <span class="p">.</span><span class="n">def</span><span class="p">(</span><span class="n">py</span><span class="o">::</span><span class="n">init</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;&gt;</span><span class="p">())</span>
        <span class="p">.</span><span class="n">def</span><span class="p">(</span><span class="s">"setName"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">Pet</span><span class="o">::</span><span class="n">setName</span><span class="p">)</span>
        <span class="p">.</span><span class="n">def</span><span class="p">(</span><span class="s">"getName"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">Pet</span><span class="o">::</span><span class="n">getName</span><span class="p">)</span>
        <span class="p">.</span><span class="n">def</span><span class="p">(</span><span class="s">"getWeights"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">Pet</span><span class="o">::</span><span class="n">getWeights</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <p><strong>类型转换</strong>：</p> <ul> <li> <code class="language-plaintext highlighter-rouge">std::string</code> ↔ Python <code class="language-plaintext highlighter-rouge">str</code> </li> <li> <code class="language-plaintext highlighter-rouge">std::vector&lt;int&gt;</code> ↔ Python <code class="language-plaintext highlighter-rouge">list</code> </li> </ul> <h3 id="python中使用绑定的类">Python中使用绑定的类</h3> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span> <span class="n">example</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">p</span> <span class="o">=</span> <span class="n">example</span><span class="p">.</span><span class="nc">Pet</span><span class="p">(</span><span class="sh">"</span><span class="s">Molly</span><span class="sh">"</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nf">print</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
<span class="o">&lt;</span><span class="n">example</span><span class="p">.</span><span class="n">Pet</span> <span class="nb">object</span> <span class="n">at</span> <span class="mh">0x10cd98060</span><span class="o">&gt;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">p</span><span class="p">.</span><span class="nf">getName</span><span class="p">()</span>
<span class="sh">'</span><span class="s">Molly</span><span class="sh">'</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">p</span><span class="p">.</span><span class="nf">setName</span><span class="p">(</span><span class="sh">"</span><span class="s">Charly</span><span class="sh">"</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">p</span><span class="p">.</span><span class="nf">getWeights</span><span class="p">()</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
</code></pre></div></div> <h2 id="绑定numpy数组">绑定NumPy数组</h2> <h3 id="numpy与c的交互">NumPy与C++的交互</h3> <p>NumPy数组可以在C++中通过<code class="language-plaintext highlighter-rouge">py::array_t&lt;Dtype&gt;</code>访问，其中<code class="language-plaintext highlighter-rouge">Dtype</code>可以是<code class="language-plaintext highlighter-rouge">double</code>、<code class="language-plaintext highlighter-rouge">float</code>、<code class="language-plaintext highlighter-rouge">int</code>。</p> <p><strong>示例：从NumPy创建Tensor</strong>：</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Tensor</span> <span class="nf">tensor_from_numpy</span><span class="p">(</span><span class="n">py</span><span class="o">::</span><span class="n">array_t</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span> <span class="n">data</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 获取输入形状</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">shape</span><span class="p">(</span><span class="n">data</span><span class="p">.</span><span class="n">ndim</span><span class="p">());</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">shape</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">shape</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">.</span><span class="n">shape</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// 创建张量</span>
    <span class="n">Tensor</span> <span class="nf">tensor</span><span class="p">(</span><span class="n">shape</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">tensor</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">tensor</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">.</span><span class="n">data</span><span class="p">()[</span><span class="n">i</span><span class="p">];</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">tensor</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p><strong>应用场景</strong>：</p> <ul> <li>使用NumPy加载图像数据</li> <li>将NumPy数组转换为自定义Tensor</li> <li>利用NumPy进行数据处理</li> </ul> <p><strong>建议</strong>：在Tensor中使用<code class="language-plaintext highlighter-rouge">std::shared_ptr</code>管理内存，便于在函数间传递和返回张量。</p> <h2 id="智能指针stdshared_ptr">智能指针std::shared_ptr</h2> <h3 id="共享指针的作用">共享指针的作用</h3> <p><strong>定义</strong>：共享指针管理一个指针的存储，可能与其他对象共享该管理。</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Pet</span><span class="o">&gt;</span> <span class="n">ptr</span><span class="p">(</span><span class="k">new</span> <span class="nf">Pet</span><span class="p">(</span><span class="s">"Cat"</span><span class="p">,</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">}));</span>
</code></pre></div></div> <p><strong>优点</strong>：</p> <ul> <li>可以将<code class="language-plaintext highlighter-rouge">ptr</code>赋值给其他智能指针</li> <li>当没有引用指向初始对象时，内存自动释放</li> <li>避免手动内存管理的错误</li> </ul> <p><strong>在Tensor中的应用</strong>：</p> <ul> <li>实现一个<code class="language-plaintext highlighter-rouge">Blob</code>类管理内存</li> <li>在Tensor中添加<code class="language-plaintext highlighter-rouge">Blob</code>的共享指针作为数据成员</li> <li>可以自由地返回张量和接受张量作为参数</li> </ul> <h2 id="使用setuppy构建">使用setup.py构建</h2> <h3 id="setuppy配置示例">setup.py配置示例</h3> <p>以mesh2sdf项目为例：</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">pybind11.setup_helpers</span> <span class="kn">import</span> <span class="n">Pybind11Extension</span><span class="p">,</span> <span class="n">build_ext</span>

<span class="n">__version__</span> <span class="o">=</span> <span class="sh">'</span><span class="s">1.1.0</span><span class="sh">'</span>

<span class="n">ext_modules</span> <span class="o">=</span> <span class="p">[</span>
    <span class="nc">Pybind11Extension</span><span class="p">(</span>
        <span class="sh">'</span><span class="s">mesh2sdf.core</span><span class="sh">'</span><span class="p">,</span>
        <span class="p">[</span><span class="sh">'</span><span class="s">csrc/pybind.cpp</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">csrc/makelevelset3.cpp</span><span class="sh">'</span><span class="p">],</span>
        <span class="n">include_dirs</span><span class="o">=</span><span class="p">[</span><span class="sh">'</span><span class="s">csrc</span><span class="sh">'</span><span class="p">],</span>
        <span class="n">define_macros</span><span class="o">=</span><span class="p">[(</span><span class="sh">'</span><span class="s">VERSION_INFO</span><span class="sh">'</span><span class="p">,</span> <span class="n">__version__</span><span class="p">)],</span>
    <span class="p">),</span>
<span class="p">]</span>
</code></pre></div></div> <p><strong>参考项目</strong>：<a href="https://github.com/wang-ps/mesh2sdf" rel="external nofollow noopener" target="_blank">mesh2sdf</a></p> <p><strong>注意</strong>：使用setup.py构建CUDA代码相对复杂，需要特殊配置。</p> <h2 id="扩展pytorch">扩展PyTorch</h2> <h3 id="ccuda扩展机制">C++/CUDA扩展机制</h3> <p>C++扩展允许用户创建PyTorch外部定义的算子：</p> <p><strong>应用场景</strong>：</p> <ul> <li>使用论文中发现的新激活函数</li> <li>实现研究中开发的自定义操作</li> <li>优化性能关键路径</li> </ul> <p><strong>官方文档</strong>：<a href="https://pytorch.org/tutorials/advanced/cpp_extension.html" rel="external nofollow noopener" target="_blank">PyTorch C++ Extensions</a></p> <h3 id="实现前向传播函数">实现前向传播函数</h3> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;torch/extension.h&gt;</span><span class="cp">
</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">torch</span><span class="o">::</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">cuda_forward</span><span class="p">(</span>
    <span class="n">torch</span><span class="o">::</span><span class="n">Tensor</span> <span class="n">input</span><span class="p">,</span>
    <span class="n">torch</span><span class="o">::</span><span class="n">Tensor</span> <span class="n">weights</span><span class="p">,</span>
    <span class="n">torch</span><span class="o">::</span><span class="n">Tensor</span> <span class="n">bias</span><span class="p">)</span> <span class="p">{</span>

    <span class="kt">int64_t</span> <span class="n">batch_size</span> <span class="o">=</span> <span class="n">data</span><span class="p">.</span><span class="n">size</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
    <span class="kt">int64_t</span> <span class="n">channel</span> <span class="o">=</span> <span class="n">data</span><span class="p">.</span><span class="n">size</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="kt">float</span><span class="o">*</span> <span class="n">ptr_in</span> <span class="o">=</span> <span class="n">input</span><span class="p">.</span><span class="n">data_ptr</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">();</span>

    <span class="n">torch</span><span class="o">::</span><span class="n">Tensor</span> <span class="n">output</span> <span class="o">=</span> <span class="n">torch</span><span class="o">::</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">input</span><span class="p">);</span>

    <span class="c1">// 在这里启动CUDA kernel</span>

    <span class="k">return</span> <span class="p">{</span><span class="n">output</span><span class="p">};</span>
<span class="p">}</span>
</code></pre></div></div> <p><strong>关键API</strong>：</p> <ul> <li> <code class="language-plaintext highlighter-rouge">torch::Tensor</code>：PyTorch张量类型</li> <li> <code class="language-plaintext highlighter-rouge">.size(dim)</code>：获取张量维度大小</li> <li> <code class="language-plaintext highlighter-rouge">.data_ptr&lt;T&gt;()</code>：获取底层数据指针</li> <li> <code class="language-plaintext highlighter-rouge">torch::zeros_like()</code>：创建相同形状的零张量</li> </ul> <h3 id="实现反向传播函数">实现反向传播函数</h3> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">torch</span><span class="o">::</span><span class="n">Tensor</span><span class="o">&gt;</span> <span class="n">cuda_backward</span><span class="p">(</span>
    <span class="n">torch</span><span class="o">::</span><span class="n">Tensor</span> <span class="n">grad_out</span><span class="p">,</span>
    <span class="n">torch</span><span class="o">::</span><span class="n">Tensor</span> <span class="n">input</span><span class="p">,</span>
    <span class="n">torch</span><span class="o">::</span><span class="n">Tensor</span> <span class="n">output</span><span class="p">,</span>
    <span class="n">torch</span><span class="o">::</span><span class="n">Tensor</span> <span class="n">bias</span><span class="p">)</span> <span class="p">{</span>

    <span class="n">torch</span><span class="o">::</span><span class="n">Tensor</span> <span class="n">grad_in</span><span class="p">,</span> <span class="n">grad_weights</span><span class="p">,</span> <span class="n">grad_bias</span><span class="p">;</span>

    <span class="c1">// 实现反向传播逻辑</span>

    <span class="k">return</span> <span class="p">{</span><span class="n">grad_in</span><span class="p">,</span> <span class="n">grad_weights</span><span class="p">,</span> <span class="n">grad_bias</span><span class="p">};</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="pybind绑定">Pybind绑定</h3> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">PYBIND11_MODULE</span><span class="p">(</span><span class="n">TORCH_EXTENSION_NAME</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">m</span><span class="p">.</span><span class="n">def</span><span class="p">(</span><span class="s">"cuda_forward"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cuda_forward</span><span class="p">,</span> <span class="s">"forward (CUDA)"</span><span class="p">);</span>
    <span class="n">m</span><span class="p">.</span><span class="n">def</span><span class="p">(</span><span class="s">"cuda_backward"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cuda_backward</span><span class="p">,</span> <span class="s">"backward (CUDA)"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <p><strong>注意</strong>：<code class="language-plaintext highlighter-rouge">TORCH_EXTENSION_NAME</code>由setup.py提供。</p> <h3 id="使用cudaextension构建">使用CUDAExtension构建</h3> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">setuptools</span> <span class="kn">import</span> <span class="n">setup</span><span class="p">,</span> <span class="n">find_packages</span>
<span class="kn">from</span> <span class="n">torch.utils.cpp_extension</span> <span class="kn">import</span> <span class="n">BuildExtension</span><span class="p">,</span> <span class="n">CUDAExtension</span>

<span class="nb">dir</span> <span class="o">=</span> <span class="sh">'</span><span class="s">./csrc</span><span class="sh">'</span>
<span class="n">sources</span> <span class="o">=</span> <span class="p">[</span><span class="sh">'</span><span class="s">{}/{}</span><span class="sh">'</span><span class="p">.</span><span class="nf">format</span><span class="p">(</span><span class="nb">dir</span><span class="p">,</span> <span class="n">src</span><span class="p">)</span> <span class="k">for</span> <span class="n">src</span> <span class="ow">in</span> <span class="n">os</span><span class="p">.</span><span class="nf">listdir</span><span class="p">(</span><span class="nb">dir</span><span class="p">)</span>
           <span class="k">if</span> <span class="n">src</span><span class="p">.</span><span class="nf">endswith</span><span class="p">(</span><span class="sh">'</span><span class="s">.cpp</span><span class="sh">'</span><span class="p">)</span> <span class="ow">or</span> <span class="n">src</span><span class="p">.</span><span class="nf">endswith</span><span class="p">(</span><span class="sh">'</span><span class="s">.cu</span><span class="sh">'</span><span class="p">)]</span>

<span class="nf">setup</span><span class="p">(</span>
    <span class="n">name</span><span class="o">=</span><span class="sh">'</span><span class="s">dwconv</span><span class="sh">'</span><span class="p">,</span>
    <span class="n">version</span><span class="o">=</span><span class="sh">'</span><span class="s">1.1.0</span><span class="sh">'</span><span class="p">,</span>
    <span class="n">packages</span><span class="o">=</span><span class="p">[</span><span class="sh">'</span><span class="s">dwconv</span><span class="sh">'</span><span class="p">],</span>
    <span class="n">include_package_data</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
    <span class="n">zip_safe</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
    <span class="n">install_requires</span><span class="o">=</span><span class="p">[</span><span class="sh">'</span><span class="s">torch</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">numpy</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">ocnn</span><span class="sh">'</span><span class="p">],</span>
    <span class="n">python_requires</span><span class="o">=</span><span class="sh">'</span><span class="s">&gt;=3.8</span><span class="sh">'</span><span class="p">,</span>
    <span class="n">ext_modules</span><span class="o">=</span><span class="p">[</span>
        <span class="nc">CUDAExtension</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="sh">'</span><span class="s">dwconv.core</span><span class="sh">'</span><span class="p">,</span> <span class="n">sources</span><span class="o">=</span><span class="n">sources</span><span class="p">)</span>
    <span class="p">],</span>
    <span class="n">cmdclass</span><span class="o">=</span><span class="p">{</span><span class="sh">'</span><span class="s">build_ext</span><span class="sh">'</span><span class="p">:</span> <span class="n">BuildExtension</span><span class="p">},</span>
<span class="p">)</span>
</code></pre></div></div> <p><strong>优势</strong>：可以使用这个方法编译CUDA文件。</p> <p><strong>参考项目</strong>：<a href="https://github.com/octree-nn/dwconv" rel="external nofollow noopener" target="_blank">dwconv</a></p> <h2 id="包装前向和反向函数">包装前向和反向函数</h2> <h3 id="使用torchautogradfunction">使用torch.autograd.Function</h3> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="n">torch.autograd</span> <span class="kn">import</span> <span class="n">Function</span>
<span class="kn">from</span> <span class="n">.core</span> <span class="kn">import</span> <span class="n">forward_cuda</span><span class="p">,</span> <span class="n">backward_cuda</span>

<span class="k">class</span> <span class="nc">OurFunction</span><span class="p">(</span><span class="n">Function</span><span class="p">):</span>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">weights</span><span class="p">):</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">.</span><span class="nf">contiguous</span><span class="p">()</span>
        <span class="n">out</span> <span class="o">=</span> <span class="nf">forward_cuda</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">weights</span><span class="p">)</span>
        <span class="n">ctx</span><span class="p">.</span><span class="nf">save_for_backward</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">weights</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">out</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">backward</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">grad</span><span class="p">):</span>
        <span class="n">data</span><span class="p">,</span> <span class="n">weights</span> <span class="o">=</span> <span class="n">ctx</span><span class="p">.</span><span class="n">saved_tensors</span>
        <span class="n">grad_d</span><span class="p">,</span> <span class="n">grad_w</span> <span class="o">=</span> <span class="nf">backward_cuda</span><span class="p">(</span><span class="n">grad</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">weights</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">grad_d</span><span class="p">,</span> <span class="n">grad_w</span>
</code></pre></div></div> <p><strong>关键概念</strong>：</p> <ul> <li> <code class="language-plaintext highlighter-rouge">@staticmethod</code>：静态方法装饰器</li> <li> <code class="language-plaintext highlighter-rouge">ctx.save_for_backward()</code>：保存前向传播中需要的张量用于反向传播</li> <li> <code class="language-plaintext highlighter-rouge">ctx.saved_tensors</code>：在反向传播中获取保存的张量</li> </ul> <h3 id="pybind总结">Pybind总结</h3> <p><strong>核心工作流程</strong>：</p> <ol> <li> <p><strong>绑定Tensor到Python</strong>：</p> <ul> <li>使用<code class="language-plaintext highlighter-rouge">shared_ptr</code>智能管理指针</li> <li>将基于指针的函数包装为基于Tensor的函数</li> <li>使用pybind绑定函数到Python</li> </ul> </li> <li> <p><strong>绑定NumPy到C++</strong>：</p> <ul> <li>实现NumPy到Tensor的转换</li> <li>利用NumPy进行数据加载和处理</li> </ul> </li> <li> <p><strong>实现Python包装类</strong>：</p> <ul> <li>包装Tensor及其梯度的Python类</li> <li>包装前向和反向传播函数的Python类</li> </ul> </li> <li> <p><strong>TODO</strong>：</p> <ul> <li>实现计算图</li> <li>实现自动微分</li> <li>实现优化算法</li> <li>最终完成网络训练</li> </ul> </li> </ol> <h2 id="单元测试">单元测试</h2> <h3 id="大型项目开发的挑战">大型项目开发的挑战</h3> <p><strong>Bug的演化</strong>：</p> <ul> <li>项目开发过程中Bug数量先增后减</li> <li>修复Bug时可能引入新Bug</li> <li>Bug修复成本随时间指数增长</li> </ul> <p><strong>解决方案</strong>：单元测试</p> <h3 id="单元测试的重要性">单元测试的重要性</h3> <p><strong>核心理念</strong>：</p> <ul> <li>大型项目由众多小单元组成</li> <li>确保每个单元的正确性</li> <li>程序员必须对自己代码的质量负责</li> <li>单元测试是对代码质量的基本承诺</li> </ul> <h3 id="单元测试的质量指标">单元测试的质量指标</h3> <p><strong>测试通过率（Test Pass Rate）</strong>：</p> <ul> <li>指测试过程中通过的测试用例比例</li> <li>单元测试通常要求100%的测试用例通过率</li> </ul> <p><strong>测试覆盖率（Test Coverage）</strong>：</p> <ul> <li>衡量测试完整性的手段</li> <li>通过覆盖率数据了解测试是否充分</li> <li>不能盲目追求覆盖率</li> <li>包括：路径覆盖、if-else分支覆盖等</li> </ul> <h2 id="测试方法">测试方法</h2> <h3 id="黑盒测试black-box-testing">黑盒测试（Black Box Testing）</h3> <p><strong>定义</strong>：也称为功能测试，将测试对象视为黑盒，不考虑程序的内部逻辑结构和内部特性。</p> <p><strong>特点</strong>：</p> <ul> <li>只检查程序功能是否满足需求规范</li> <li>关注输入和输出的关系</li> <li>不关心内部实现</li> </ul> <p><strong>测试方法</strong>：</p> <p><strong>1. 等价类划分</strong>：</p> <ul> <li>将输入域划分为等价类</li> <li>小于范围、在范围内、大于范围</li> </ul> <p><strong>2. 边界值分析</strong>：</p> <ul> <li>大多数故障倾向于发生在输入或输出域的边界</li> <li>测试边界值附近的情况</li> </ul> <p><strong>3. 鲁棒性测试</strong>：</p> <ul> <li>添加略大于/小于最大值/最小值的值</li> <li>检查超出极限值时系统的行为</li> </ul> <h3 id="白盒测试white-box-testing">白盒测试（White Box Testing）</h3> <p><strong>定义</strong>：也称为结构测试，将测试对象视为透明盒，允许测试人员使用程序的内部逻辑结构和相关信息来设计或选择测试用例。</p> <p><strong>目标</strong>：</p> <ul> <li>测试/覆盖所有路径、分支和逻辑</li> <li>构造测试用例确保所有代码路径被执行</li> </ul> <p><strong>示例</strong>：</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">double</span> <span class="nf">func1</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">,</span> <span class="kt">double</span> <span class="n">c</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">a</span><span class="o">&gt;</span><span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">b</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>     <span class="c1">// ①</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">c</span><span class="o">/</span><span class="n">a</span><span class="p">;</span>          <span class="c1">// ②</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">a</span><span class="o">&gt;</span><span class="mi">1</span> <span class="o">||</span> <span class="n">c</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>     <span class="c1">// ③</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">c</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span>          <span class="c1">// ④</span>
    <span class="p">}</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">b</span><span class="o">+</span><span class="n">c</span><span class="p">;</span>              <span class="c1">// ⑤</span>
    <span class="k">return</span> <span class="n">c</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p><strong>测试策略</strong>：构造测试用例确保路径①-⑤都被覆盖，包括：</p> <ul> <li>条件1为真和为假的情况</li> <li>条件2为真和为假的情况</li> <li>所有分支组合</li> </ul> <h2 id="python-unittest框架">Python Unittest框架</h2> <h3 id="基本使用">基本使用</h3> <p><strong>继承unittest.TestCase</strong>：</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">unittest</span>
<span class="kn">from</span> <span class="n">mul</span> <span class="kn">import</span> <span class="n">multiply</span>

<span class="k">class</span> <span class="nc">MultiplyTestCase</span><span class="p">(</span><span class="n">unittest</span><span class="p">.</span><span class="n">TestCase</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">test_multiplication_with_correct_values</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="nf">assertEqual</span><span class="p">(</span><span class="nf">multiply</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="mi">25</span><span class="p">)</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="sh">'</span><span class="s">__main__</span><span class="sh">'</span><span class="p">:</span>
    <span class="n">unittest</span><span class="p">.</span><span class="nf">main</span><span class="p">()</span>
</code></pre></div></div> <p><strong>关键要点</strong>：</p> <ul> <li>继承<code class="language-plaintext highlighter-rouge">unittest.TestCase</code> </li> <li>测试方法名以<code class="language-plaintext highlighter-rouge">test_</code>开头</li> <li>使用<code class="language-plaintext highlighter-rouge">self.assertEqual</code>判断测试是否通过</li> </ul> <h3 id="常用断言方法">常用断言方法</h3> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">self</span><span class="p">.</span><span class="nf">assertEqual</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>      <span class="c1"># a == b
</span><span class="n">self</span><span class="p">.</span><span class="nf">assertNotEqual</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>   <span class="c1"># a != b
</span><span class="n">self</span><span class="p">.</span><span class="nf">assertTrue</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>          <span class="c1"># bool(x) is True
</span><span class="n">self</span><span class="p">.</span><span class="nf">assertFalse</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>         <span class="c1"># bool(x) is False
</span><span class="n">self</span><span class="p">.</span><span class="nf">assertIs</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>         <span class="c1"># a is b
</span></code></pre></div></div> <h3 id="setup和teardown">setUp和tearDown</h3> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">MulTestCase</span><span class="p">(</span><span class="n">unittest</span><span class="p">.</span><span class="n">TestCase</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">setUp</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>  <span class="c1"># 在每个测试方法之前运行
</span>        <span class="n">self</span><span class="p">.</span><span class="n">a</span> <span class="o">=</span> <span class="mi">10</span>
        <span class="n">self</span><span class="p">.</span><span class="n">b</span> <span class="o">=</span> <span class="mi">20</span>

    <span class="k">def</span> <span class="nf">test_mult_with_correct_values</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>
        <span class="n">self</span><span class="p">.</span><span class="nf">assertEqual</span><span class="p">(</span><span class="nf">multiply</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">a</span><span class="p">,</span> <span class="n">self</span><span class="p">.</span><span class="n">b</span><span class="p">),</span> <span class="mi">200</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">tearDown</span><span class="p">(</span><span class="n">self</span><span class="p">):</span>  <span class="c1"># 在每个测试方法之后运行
</span>        <span class="k">del</span> <span class="n">self</span><span class="p">.</span><span class="n">a</span>
        <span class="k">del</span> <span class="n">self</span><span class="p">.</span><span class="n">b</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="sh">'</span><span class="s">__main__</span><span class="sh">'</span><span class="p">:</span>
    <span class="n">unittest</span><span class="p">.</span><span class="nf">main</span><span class="p">()</span>
</code></pre></div></div> <p><strong>作用</strong>：</p> <ul> <li> <code class="language-plaintext highlighter-rouge">setUp()</code>：初始化测试环境，每个测试方法前运行</li> <li> <code class="language-plaintext highlighter-rouge">tearDown()</code>：清理测试环境，每个测试方法后运行</li> </ul> <h2 id="xunit和mock测试">xUnit和Mock测试</h2> <h3 id="xunit适用场景">xUnit适用场景</h3> <p>xUnit通常适用于以下测试场景：</p> <ul> <li>单个函数、类或几个功能相关类的测试</li> <li>特别适合纯函数测试或接口级测试</li> </ul> <h3 id="mock测试">Mock测试</h3> <p><strong>定义</strong>：使用虚拟对象（Mock对象）来模拟真实对象进行测试。</p> <p><strong>使用场景</strong>：</p> <ul> <li>真实对象难以创建</li> <li>真实对象具有用户界面</li> <li>真实对象实际上不存在</li> </ul> <p><strong>作用</strong>：</p> <ul> <li>隔离依赖</li> <li>简化测试环境</li> <li>提高测试可控性</li> </ul> <h2 id="课程前半部分总结">课程前半部分总结</h2> <h3 id="已学习的内容">已学习的内容</h3> <p><strong>第1章 - 引言</strong>：</p> <ul> <li>GPU并行计算的必要性</li> <li>第一个PyTorch程序</li> </ul> <p><strong>第2章 - 并行编程</strong>：</p> <ul> <li>线程、延迟和带宽</li> <li>ReLU、Sigmoid激活函数</li> <li>GPU内存模型：全局内存、共享内存等</li> </ul> <p><strong>第3章 - 并行通信</strong>：</p> <ul> <li>并行线程交互：同步、原子操作等</li> <li>内存一致性、GPU Stream</li> </ul> <p><strong>第4章 - 并行算法I</strong>：</p> <ul> <li>Reduce、Histogram、Scan、Compact</li> </ul> <p><strong>第5章 - 并行算法II</strong>：</p> <ul> <li>分段扫描、转置、排序</li> </ul> <p><strong>第6章 - 矩阵乘法</strong>：</p> <ul> <li>矩阵乘法和稀疏矩阵乘法</li> <li>引入cuBLAS和Thrust</li> <li>全连接层、GEMM</li> </ul> <p><strong>第7章 - 卷积和池化</strong>：</p> <ul> <li>卷积、池化</li> <li>损失函数、Softmax</li> </ul> <p><strong>第8章 - 混合编程和单元测试</strong>：</p> <ul> <li>Pybind、CMakeLists</li> <li>扩展PyTorch</li> <li>单元测试</li> </ul> <h2 id="深度学习框架的架构层次">深度学习框架的架构层次</h2> <h3 id="三层架构">三层架构</h3> <p><strong>底层：硬件特定后端</strong>：</p> <ul> <li>CPU、GPU或移动处理器</li> <li>C++/CUDA或移动设备上的其他编程语言</li> <li>并行编程思想的实现</li> </ul> <p><strong>中层：脚本语言</strong>：</p> <ul> <li>计算图</li> <li>自动微分</li> <li>模型/数据并行</li> </ul> <p><strong>系统层：分布式计算</strong>：</p> <ul> <li>跨机器/GPU训练大型模型</li> <li>分布式训练策略</li> </ul> <p>通过Pybind11，我们实现了底层高性能计算和上层灵活接口的无缝连接，这是现代深度学习框架的核心架构模式。</p> <h2 id="总结">总结</h2> <h3 id="混合编程的最佳实践">混合编程的最佳实践</h3> <ol> <li> <p><strong>使用Pybind11连接Python和C++</strong>：</p> <ul> <li>简单的API设计</li> <li>自动类型转换</li> <li>高效的数据传递</li> </ul> </li> <li> <p><strong>智能指针管理内存</strong>：</p> <ul> <li>使用<code class="language-plaintext highlighter-rouge">std::shared_ptr</code>避免内存泄漏</li> <li>实现安全的对象生命周期管理</li> </ul> </li> <li> <p><strong>扩展PyTorch</strong>：</p> <ul> <li>实现自定义算子的前向和反向传播</li> <li>使用<code class="language-plaintext highlighter-rouge">torch.autograd.Function</code>集成到自动微分系统</li> <li>利用<code class="language-plaintext highlighter-rouge">CUDAExtension</code>简化构建流程</li> </ul> </li> <li> <p><strong>单元测试保证质量</strong>：</p> <ul> <li>100%的测试通过率</li> <li>合理的测试覆盖率</li> <li>黑盒测试和白盒测试结合</li> </ul> </li> </ol> <p>通过掌握这些技术，我们可以构建高性能、可维护的深度学习系统，充分发挥Python的灵活性和C++/CUDA的高效性。</p> </div> </article> <br> <hr> <br> <ul class="list-disc pl-8"></ul> <h2 class="text-3xl font-semibold mb-4 mt-12">Enjoy Reading This Article?</h2> <p class="mb-2">Here are some more articles you might like to read next:</p> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2025/09/08/notesof_ML/">notes of ML</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2025/09/08/notesofvci/">notes of VCI</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2025/09/08/notesofaip/">notes of AIP</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2025/09/08/notesof_aimath/">notes of AI Math Fundamentals</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2025/09/08/notesof_ICS/">notes of ICS</a> </li> </div> </div> <footer class="fixed-bottom" role="contentinfo"> <div class="container mt-0"> © Copyright 2025 stibiums liu. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. Photos from <a href="https://unsplash.com" target="_blank" rel="external nofollow noopener">Unsplash</a>. Last updated: October 17, 2025. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@5.0.0/imagesloaded.pkgd.min.js" integrity="sha256-htrLFfZJ6v5udOG+3kNLINIKh2gvoKqwEhHYfTTMICc=" crossorigin="anonymous"></script> <script defer src="/assets/js/masonry.js?a0db7e5d5c70cc3252b3138b0c91dcaf" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?85ddb88934d28b74e78031fd54cf8308"></script> <script src="/assets/js/no_defer.js?2781658a0a2b13ed609542042a859126"></script> <script defer src="/assets/js/common.js?e0514a05c5c95ac1a93a8dfd5249b92e"></script> <script defer src="/assets/js/copy_code.js?c8a01c11a92744d44b093fc3bda915df" type="text/javascript"></script> <script defer src="/assets/js/jupyter_new_tab.js?d9f17b6adc2311cbabd747f4538bb15f"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js" integrity="sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI=" crossorigin="anonymous"></script> <script src="/assets/js/mathjax-setup.js?58fdb075e5aa03fbb8617845abde746c"></script> <script defer src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6" crossorigin="anonymous"></script> <script defer src="/assets/js/progress-bar.js?2f30e0e6801ea8f5036fa66e1ab0a71a" type="text/javascript"></script> <script src="/assets/js/vanilla-back-to-top.min.js?f40d453793ff4f64e238e420181a1d17"></script> <script>
    addBackToTop();
  </script> <script type="module" src="/assets/js/search/ninja-keys.min.js?a3446f084dcaecc5f75aa1757d087dcf"></script> <ninja-keys hidebreadcrumbs noautoloadmdicons placeholder="Type to start searching"></ninja-keys> <script src="/assets/js/search-setup.js?6c304f7b1992d4b60f7a07956e52f04a"></script> <script src="/assets/js/search-data.js"></script> <script src="/assets/js/shortcut-key.js?6f508d74becd347268a7f822bca7309d"></script> </body> </html>